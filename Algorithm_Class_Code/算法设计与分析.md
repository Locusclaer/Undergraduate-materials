[toc]

# 算法设计与分析

## 概论

### 算法的概念

> 什么是算法设计？什么与之相关，什么无关？

算法是求解问题的一系列计算步骤，用来将输入数据转换成输出结果。

算法设计的目标：

1. 正确性
2. 可使用性/用户友好性
3. 可读性
4. 健壮性
5. 高效率与低存储需求

算法的特性：

1. 有限性
2. 确定性
3. 可行性
4. 输入性
5. 输出性

> 算法设计的基本步骤？

1. 分析求解问题
2. 选择数据结构和算法设计策略
3. 描述算法
4. 证明算法正确性
5. 算法分析

### 算法分析

> 什么是算法分析？

分析**算法占用计算机资源的情况**，两个主要方面是分析算法的**时间复杂度和空间复杂度**。

> 算法的时间复杂度、空间复杂度

算法执行时间主要与**问题规模**有关。算法中**基本语句**是执行次数与整个算法执行次数成正比的语句。

渐进符号：

$f(n) = O(g(n)) \coloneqq \left\{f(n) | \exist c, n_0 > 0, 0\le f(n)\le cg(n) \right\}$ ： $g(n) 是 f(n) 上界$

$f(n) = \Omega(g(n)) \coloneqq \left\{f(n) | \exist c, n_0 > 0, 0\le cg(n)\le f(n) \right\}$ ：$g(n) 是 f(n) 下界$

$f(n) = \Theta(g(n)) \coloneqq \left\{f(n) | \exist c_1,c_2,n_0 > 0, 0\le  c_1g(n)\le  f(n)\le c_2g(n) \right\}$： $ g(n) 是 f(n) 同阶 $

![渐进复杂度](.\assets\渐进复杂度.png)

最好、平均、最坏时间复杂度

### STL 工具

不会的话可以 REMAKE 了。

顺序容器：`array`，`vector`，`deque`，`forward_list`，`list`

关联容器：`set`，`map`

无序关联容器：`unordered_set`，`unordered_map`

容器适配器：`stack`，`queue`，`priority_queue`

## 递归

### 什么是递归

> 何时使用递归？（三种情况举例说明）

1. 定义是递归的：数学公式如 $n!$ 和**斐波那契数列**
2. 数据结构是递归的：**单链表、二叉树**
3. 问题的求解方法是递归的：**Hanoi 塔问题**

> 递归模型

分为**递归出口**和**递归体**，前者指出明确的递归结束，后者确定递归求解的递推关系

> 递归算法的执行过程

递归树

### 递归算法设计

> 第一、第二数学归纳法

第一数学归纳法

1. $P(0)$ 为真
2. 由 $P(k)$ 为真，可推出 $P(k + 1)$ 为真

第二数学归纳法

1. $P(0)$ 为真
2. 由 $n \le k$ 时 $P(n)$ 为真，可推出 $P(k + 1)$ 为真

第二数学归纳法证明了**先序/后序和中序可唯一确定一颗二叉树**。

> 基于归纳思想的递归算法设计（编程题目）

子问题不独立。其他看命。

### 递归式的计算

> 递归方程

递归算法的执行时间可以用递归形式（递推式）来表示，递推式也成为递归方程。

> 递归算法时间复杂度分析

1. $f(n) = a_1f(n - 1) + a_2f(n - 2) + \cdots + a_kf(n - k)$，会求一阶二阶
2. $f(n) = a_1f(n - 1) + a_2f(n - 2) + \cdots + a_kf(n - k) + g(n)$，等死
3. 主定理 $T(n) = aT(n / b) + f(n)$![主定理](E:\算法设计与分析\算法设计与分析\assets\主定理.png)

## 分治

### 分治法概述

> 分治法定义以及时间复杂度**（理解到具体细节）**

对于一个规模为 $n$ 的问题，若该问题可以容易的求解则直接解决，否则将其分解为 $k$ 个规模较小的子问题，**这些子问题相互独立且与原问题形式相同**，递归地解这些子问题，然后**将各子问题的解合并得到原问题的解**，这种算法设计策略叫做**分治法**。

时间复杂度：

$$
T(n) = \begin{cases}
\Theta(1) &, n \le n_0 \\
aT(n/b) + D(n) + C(n) &, n > n_0
\end{cases}
$$


> 分治法分割原则及其原因

1. 该问题的规模缩小的一定的程度可以容易地解决（绝大多数）
2. 该问题可以分解为若干个规模较小的相似问题（**前提**，反映了递归思想）
3. 利用该问题分解出的子问题的解可以合并为该问题的解（**关键**）
4. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题（效率）

如果具备特征 1 和 2，而不具备特征 3，一般考虑贪心法或动态规划。
不满足特征 4 虽然可以用分治，但是更推荐用动态规划。

当 $k = 1$ 时称为减治法，许多问题可以取 $k = 2$ 称为二分法。

### 求解排序问题

> 快速排序思想、时间复杂度、递归方程

思想：

在待排序的 n 个元素中任意取一个元素作为**基准**。把该元素放入最终位置后，整个序列被基准分割为两个子序列，所有小于基准的元素放在前子序列中，所有大于基准的元素放在后子序列中，并把基准排在两个子序列的中间，这个过程称为**划分**。然后对两个子序列分别重复上述过程，直到每个子序列内只有一个元素或空为止。

时间复杂度：

|     最好      |     平均      |   最坏   |
| :-----------: | :-----------: | :------: |
| $O(n\log{n})$ | $O(n\log{n})$ | $O(n^2)$ |

递归方程：

$$
T(n) = \begin{cases}
    1 & , n = 1 \\
    T(\alpha n) + T((1 - \alpha)n) + \Theta(n) & , n > 1
\end{cases}
$$

划分产生的两个子序列长度比为 $\alpha : 1 - \alpha$，其中 $0 < \alpha < 1$。

> 归并排序思想、时间复杂度、递归方程

思想：

首先将 $a[0\dots n - 1]$ 看成长度为 1 的有序表，然后将相邻的 $k\ge 2$ 个有序子表归并，得到 $n/k$ 个长度为 $k$ 的有序子表；然后再将这些有序子表继续归并，得到 $n/k^2$ 个长度为 $k^2$ 的有序子表，如此反复下去得到一个长度为 $n$ 的有序表。
$k = 2$ 时称为二轮归并排序，$k > 2$ 时称为多路归并排序。

时间复杂度：$\Theta(n\log{n})$

递归方程：

$$
T(n) = \begin{cases}
    1 & , n = 1 \\
    2T(n / 2) + \Theta(n) & , n > 1
\end{cases}
$$

### 求解查找问题

#### 查找最大和次大元素

```cpp
std::pair<int, int> findTopTwo(const std::vector<int>& nums, int left, int right) {
    if (left == right) {
        return { nums[left], INT_MIN };
    }
    if (right - left == 1) {
        if (nums[left] > nums[right]) {
            return { nums[left], nums[right] };
        } else {
            return { nums[right], nums[left] };
        }
    }

    int mid = left + (right - left) / 2;
    auto leftPair = findTopTwo(nums, left, mid);
    auto rightPair = findTopTwo(nums, mid + 1, right);

    int first, second;
    if (leftPair.first > rightPair.first) {
        first = leftPair.first;
        second = std::max(leftPair.second, rightPair.first);
    } else {
        first = rightPair.first;
        second = std::max(rightPair.second, leftPair.first);
    }
    return { first, second };
}
```

#### 折半查找

```cpp
int binarySearch(const std::vector<int>& nums, int low, int high, int k) {
    if (low > high) return -1;
    int mid = (left + right) / 2;
    if (nums[mid] == k) 
        return mid;
    else if (nums[mid] > k) 
        rteurn binarySearch(nums, low, mid - 1, k);
    else
        return binarySearch(nums, mid + 1, high, k);
}
```

#### 寻找序列中第 k 小的元素

```cpp
int select(std::vector<int>& nums, int low, int high, int k) {
    if (low == high && low == k - 1) {
        return nums[k - 1];
    }

    // 划分开始
    int i = low, j = high, temp = a[low];
    while (i != j) {
        while (j > i && nums[j] >= temp) {
            --j;
        }
        nums[i] = nums[j];
        while (i < j && nums[i] <= temp) {
            ++i;
        }
        nums[j] = nums[i];
    }
    nums[i] = temp;
    // 划分结束

    // 开始递归
    if (i == k - 1)
        return nums[i];
    if (i > k - 1)
        return select(nums, low, i - 1, k);
    return select(nums, i + 1, high, k);
}
```

#### 寻找两个等长有序序列的中位数

短的数组取后一半

```cpp
int midmum(std::vector<int>& a, int s1, int t1, std::vector<int>& b, int s2, int t2) {
    if (s1 == t1 && s2 == t2) { // 如果两个序列都只有一个数
        return std::min(a[s1], b[s2]);
    }
    int m1 = (s1 + t1) / 2; // 序列1中位数下标
    int m2 = (s2 + t2) / 2; // 序列2中位数下标
    if (a[m1] == b[m2])
        return a[m1];
    if (a[m1] < b[m2]) {
        s1 = m1 + ((s1 + t1) & 1); // a 取后半
        t2 = m2;                   // b 取前半
        return midmum(a, s1, t1, b, s2, t2);
    }
    t1 = m1;                   // a 取前半
    s2 = m2 + ((s2 + t2) & 1); // b 取后半
    return midmum(a, s1, t1, b, s2, t2);
}
```

### 求解组合问题

#### 最大连续子序列和

```cpp
int maxSubSum(const std::vector<int>& nums, int low, int high) {
    if (low == high) {
        return nums[low];
    }
    int mid = (low + high) / 2;
    int leftMaxSum = maxSubSum(nums, left, mid);
    int rightMaxSum = maxSubSum(nums, mid + 1, right);
    
    int leftSum = INT_MIN, rightSum = INT_MIN;
    int sum = 0;
    for (int i = mid; i >= low, --i) {
        sum += nums[i];
        if (sum > leftSum) {
            leftSum = sum;
        }
    }
    sum = 0;
    for (int i = mid + 1; i <= high, ++i) {
        sum += nums[i];
        if (sum > rightSum) {
            rightSum = sum;
        }
    }
    return std::max({ leftMaxSum, leftSum + rightSum, rightMaxSum });
}
```

#### 棋盘覆盖

```cpp
// k 是棋盘大小，(x, y) 是特殊方格，tile 是骨牌编号
int k, x, y, tile = 1;
int board[MAX][MAX];
// (tr, tc) 是棋盘左上角，(dr, dc) 是特殊方格，size 是行列数
void chessBoard(int tr, int tc, int dr, int dc, int size) {
    if (size == 1) return;
    int t = tile++;
    int s = size / 2;
	// 特殊方格在左上
    if (dr < tr + s && dc < tc + s) {
        chessBoard(tr, tc, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s - 1] = t; // 在此象限右下角防止骨牌
        chessBoard(tr, tc, tr + s - 1, tc + s - 1, s);
    }
	// 在右上
    if (dr < tr + s && dc >= tc + s) {
        chessBoard(tr, tc + s, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s] = t;
        chessBoard(tr, tc + s, tr + s - 1, tc + s, s);
    }
	// 在左下
    if (dr >= tr + s && dc < tc + s) {
        chessBoard(tr + s, tc, dr, dc, s);
    } else {
        board[tr + s][tc + s - 1] = t;
        chessBoard(tr + s, tc, tr + s, tc + s - 1, s);
    }
	// 在右下
    if (dr >= tr + s && dc >= tc + s) {
        chessBoard(tr + s, tc + s, dr, dc, s);
    } else {
        board[tr + s][tc + s] = t;
        chessBoard(tr + s, tc + s, tr + s, tc + s, s);
    }
}
```

## 大力出奇迹

### 蛮力法概述

> 使用蛮力法的几种情况

1. 搜索**所有**解空间
2. 搜索**所有**路径
3. 直接计算
4. 模拟和仿真

### 蛮力法的基本应用

#### 计算结果为 100 的加减法表达式

```cpp
void findExpressions(vector<string>& results, string currentExpr, int currentPos, int currentSum, int currentNum, int target) {
    // results：存储所有符合条件的表达式；currentExpr:当前表达式； currentPos:当前处理的数字； currentSum：当前的和（不包括currentNum）；currentNum:当前正在构造的数字；target：目标值
    if (currentPos > 9) {
        // 所有数字处理完毕，检查是否等于目标值
        if (currentSum + currentNum == target) {
            results.push_back(currentExpr + "9 = " + to_string(target));
        }
        return;
    }

    // 情况1：不插入运算符（连接数字，如 1 和 2 变成 12）
    if (currentPos != 9) { // 减枝
        findExpressions(results, currentExpr, currentPos + 1, currentSum, currentNum * 10 + currentPos, target);
    }

    // 插入 '+'（先计算 currentNum，然后加上新数字）
    string newExpr = currentExpr + to_string(currentNum) + " + ";
    findExpressions(results, newExpr, currentPos + 1, currentSum + currentNum, currentPos, target);

    // 情况3：插入 '-'（先计算 currentNum，然后减去新数字）
    newExpr = currentExpr + to_string(currentNum) + " - ";
    findExpressions(results, newExpr, currentPos + 1, currentSum + currentNum, -currentPos, target);
}
```

#### 最大连续子序列和

```cpp
int maxSubSum(const std::vector<int>& nums) {
    int maxSum = 0, current = 0;
    for (int i = 0; i < nums.size(); ++i) {
        current += nums[i];
        if (current < 0) {
            current = 0;
        }
        if (maxSum < current) {
            maxSum = current;
        }
    }
    return maxSum;
}
```

#### 子集和全排列

```cpp
auto PSet(int n) -> std::vector<std::vector<int>> {
    std::vector<std::vector<int>> ps;
    std::vector<std::vector<int>> ps1;
    ps.emplace_back({});
    for (int i = 1; i <= n; ++i) {
        ps1 = ps; // 先拷贝一份ps
        for (auto it = ps1.begin(); it != ps1.end(); ++it) { // 在ps1中添加元素
            it->push_back(i);
        }
        for (auto it = ps1.begin(); it != ps1.end(); ++it) { // 将ps1中的元素添加到ps中
            ps.push_back(std::move(*it));
        }
    }
    return ps;
}
```

```cpp
auto Permutation(int n) -> std::vector<std::vector<int>> {
    std::vector<std::vector<int>> perm;
    perm.emplace_back({1});

    for (int i = 2; i <= n; ++i) {
        std::vector<std::vector<int>> new_perm;
        for (const auto& p : perm) {
            auto new_p = p;
            for (int pos = 0; pos <= p.size(); ++pos) {
                new_p.insert(new_p.begin() + pos, i); // 在哪，加什么
                new_perm.push_back(new_p);
                new_p.erase(new_p.begin() + pos);
            }
        }
        perm = std::move(new_perm);
    }
    return perm;
}
```

## 回溯法

### 回溯法的概念

> 解空间(树)、子集树、排列树的概念

一个复杂问题的解决方案是由若干个小的决策步骤组成的决策序列，所以一个问题的解可以表示成解向量 $X = \qty(x_1, x_2, \cdots, x_n)$，其中分量 $x_i$ 对应第 $i$ 步的选择，通常可以有两个或多个取值，表示为 $s_i \in S_i$，$S_i$ 为 $x_i$ 的取值候选集。$X$ 中各个分量 $x_i$ 的所有取值构成问题的解向量空间，简称**解空间**或者**解空间树**，由于一个解向量往往对应问题的某个状态，所有解空间又称为问题的**状态空间树**。

解空间树通常有两种类型：
当所给的问题是从 $n$ 个元素的集合 $S$ 中**找到满足某种性质的子集**时，相应的解空间树称为**子集树**。
当所给问题时确定 $n$ 个元素**满足某种性质的排列**时，相应的解空间树称为**排列树**。

> 回溯法的效率和一般解题策略

效率：

假设解空间树共有 $n$ 层，第 $i$ 层有 $m_{i - 1}$ 个满足约束条件的结点，每个结点有 $m_i$ 个满足约束条件的解，则第 $i + 1$ 层有 $m_0m_1\cdots m_i$ 个满足约束条件的结点，因此回溯法的执行时间为 $T(n) = m_0 + m_0m_1 + \cdots + m_0m_1\cdots m_{n - 1}$。
通常情况下，回溯法的效率会高于蛮力法。子集树时间为 $O(2^n)$，排列树时间为 $O(n!)$。

一般解题策略：

1. 针对给定的问题**确定解空间树**，问题的解空间树应至少包含问题的一个解或最优解。
2. 确定结点的**扩展搜索**规则。
3. 以 DFS 方式搜索解空间树，并在搜索过程中可以采用剪枝函数[^1]来避免无效搜索。

[^1]: 剪枝函数包含两类函数：一类用**约束函数**在扩展结点处剪除不满足约束条件的路径，二是用**限界函数**剪去得不到问题解或最优解的路径。

### 回溯法的应用

> 会用回溯法求解子集问题、排列问题、0/1 背包问题；能看懂装载问题、任务分配问题、流水作业调度问题

#### 子集问题

```cpp
void dfs(const std::vector<int>& a, int i, std::deque<bool>& x) {
    if (i >= a.size()) {
        display(a, x);
        return;
    }
    x[i] = false;
    dfs(a, i + 1, x);
    x[i] = true;
    dfs(a, i + 1, x);
}
```

#### 排列问题

```cpp
void dfs(std::vector<int>& a, int i) {
    if (i >= n) {
        display(a);
        return;
    }
    for (int j = i; j < n; ++j) {
        std::swap(a[i], a[j]);
        dfs(a, i + 1);
        std::swap(a[i], a[j]);
    }
}
```

#### 0/1 背包问题

```cpp
void dfs(int i, int tw, int tv, int rw, std::deque<bool>& op) {
    // tw: total weight 已选物品的总重量; tv: total value 已选物品的总价值; rw: remaining weight 未处理物品的总重量; op:物品是否选中
    if (i > n) { // 所有物品处理完毕
        if (tw == W && tv > maxv) {
            maxv = tv;
            for(int j = 1; j <= n; ++j) {
                x[j] = op[j]; // 选了的物品存到x中
            }
        }
        return;
    }
    if (tw + w[i] <= W) {
        op[i] = true;
        dfs(i + 1, tw + w[i], tv + v[i], rw - w[i], op);
        op[i] = false;
    }
    if (tw + rw > W) { 
        dfs(i + 1, tw, tv, rw - w[i], op);
    }
}
```

> 能够根据题意判断解空间的类型

无技巧可言，只能看解的形式。

> 掌握回溯法的递归算法框架

解空间为子集树：

```cpp
std::vector<int> x(n);
void backtrack(int i) {
    if (i > n) {
        display(...);
        return;
    }
    for (int j = low; j <= high; ++j) {
        x[i] = j;
        ...;
        if (constraint(i) && bound(i)) {
            backtrack(i + 1);
        }
    }
}
```

解空间为排列树：

```cpp
std::vector<int> x(n);
void backtrack(int i) {
    if (i > n) {
        display(...);
        return;
    }
    for (int j = i; j <= n; ++j) {
        ...;
        if (constraint(i) && bound(i)) {
            std::swap(x[i], x[j]);
            backtrack(i + 1);
            std::swap(x[i], x[j]);
        }
        ...;
    }
}
```

> 掌握常用的剪枝方法

“加上”后已经超过解/最优解，“加上”后面所有也达不到解/比更优解优。

## 分枝限界法

### 分枝限界法概述

> “分枝”和“限界”的概念

分枝限界法的求解目标是**找出满足约束条件的一个解**，或者在满足约束条件的解中**找出一个最优解**。

分枝：采用 BFS 策略依次搜索活结点的所有分枝，也就是所有相邻节点。

限界：为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处计算一个限界函数，并根据这些已计算出的函数值从当前活结点表中选择一个最有利的结点作为扩展结点，使**搜索朝着解空间树上有最优解的分枝推进**，以便尽快的找出一个最优解。

> 分枝限界法与回溯法的区别

| 方法       | 解空间搜索方式 | 存储节点的数据结构 | 结点存储特性                               | 常见应用                                 |
| ---------- | -------------- | ------------------ | ------------------------------------------ | ---------------------------------------- |
| 回溯法     | 深度优先       | 栈                 | 活结点的所有可行子节点被遍历后才从栈中出栈 | 找出满足条件的所有解                     |
| 分枝限界法 | 广度优先       | 队列、优先队列     | 每个结点只有一次成为活结点的机会           | 找出满足条件的一个解或特性意义下的最优解 |

> 掌握两种实现分枝限界法的搜索方式：队列式、优先队列式

队列式：

1. 将根节点加入活结点队列。
2. 从活结点队列中取出队头结点作为当前扩展结点。
3. 对于当前扩展结点，先从左到右产生他的所有子结点，用约束条件检查，把所有满足约束条件的子节点加入队列。
4. 重复步骤（2）和（3）直到找到一个解或队列为空为止。

优先队列式：

1. 计算根结点的优先级并加入优先队列。
2. 从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推进，以便尽快的找出一个最优解。
3. 对于当前扩展结点，先从左到右产生它的所有子结点，然后用约束条件检查，对所有满足约束条件的子节点计算优先级并加入优先队列。
4. 重复步骤（2）和（3）直到找到一个解或队列为空为止。

### 分枝限界法的应用

> 能看懂 0-1 背包问题、任务分配问题、流水作业调度问题的分枝限界解法

略。

## 贪心法

### 贪心法概述

> 贪心法的基本原理

贪心法的基本思路是：在对问题求解时总是做出**在当前看来时最好的选择**，也就是说贪心法不从整体最优上加以考虑，所做出的仅是某种意义上的局部最优解。当满足一定条件时，这些局部最优解可以转变成整体最优解。

> 贪心法应具有的性质：贪心选择性质、最优子结构性质

贪心选择性：所求问题的整体最优解可以通过一系列局部最优的选择来达到，**是使用贪心法可行的基本要素，也是与动态规划的主要区别**。

最优子结构：一个问题的最优解包含其子问题的最优解，**是该问题可以用贪心或动态规划的关键特征**。

### 贪心法的应用

> 会用贪心法求解活动安排、部分背包、最优装载、田忌赛马、多机调度、哈夫曼编码（结点数与字符数关系）、流水作业调度问题及相应的时间复杂度

| 问题             | 时间复杂度    |
| ---------------- | ------------- |
| 活动安排         | $O(n\log{n})$ |
| 部分背包         | $O(n\log{n})$ |
| 最优装载         | $O(n\log{n})$ |
| 田忌赛马         | $O(n\log{n})$ |
| 多机调度         | $O(n\log{n})$ |
| 流水作业调度问题 | $O(n\log{n})$ |

#### 活动安排

[问题描述] 设有一个需要使用某一资源的由 $n$ 个活动组成的集合 $S$，$S =(1,\cdots,n)$。该资源在任何时刻只能被一个活动所占用，活动 $i$ 有一个开始时间 $b_i$ 和结束时间 $e_i$，其执行时间为 $e_i - b_i$，假设最早活动执行时间为 0。一旦某个活动开始执行，就不能被打断，直到其执行完毕。若活动 $i$ 和活动 $j$ 有 $b_i\ge e_j$ 或 $b_j\ge e_i$，则称这两个活动兼容。设计算法求一种最优活动安排方案，使得所有安排的活动个数最多。

[贪心策略] 每一步总是选择这样一个活动来占用资源，它能够使得余下的未调度的时间最大化，使得兼容的活动尽可能多。

```cpp
struct Action {
	int b{};
    int e{};
    bool choose{};
    bool operator<(const Action& that) const { return e < that.e; } // 按结束时间排序
};

void solve(std::vector<Action>& A) {
    const int n = A.size();
    std::sort(A.begin(), A.end());
    int pre_end = 0; // 上一个的结束时间
    for (int i{}; i <= n; ++i) {
        if (A[i].b >= pre_end) { // 如果开始时间大于结束时间
            A[i].choose = true;
            pre_end = A[i].e;
        }
    }
}
```

#### 部分背包

[问题描述] 有 $n$ 个重量分别为 $w_1$、$w_2$、$\cdots$、$w_n$ 的物品（物品编号为 1~$n$），它们的价值分别为 $v_1$、$v_2$、$\cdots$、$v_n$，给定一个容量为 $W$ 的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品可以取一部分装入背包，要求装入背包的物品具有最大的价值。

[贪心策略] 选择**单位重量**下价值最大的物品。

```cpp
struct Item {
	double weight{};
    double value{};
    double vpw{};  // 找重量价值
    double choose{};
    
    bool operator<(const Item& that) { return vpw < that.vpw; }
};

double solve(std::vector<Item>& A, double W) {
	int value = 0;
    double weight = W;
    std::sort(A.begin(), A.end(), std::greater<Item>()); // 按单位价值从大到小排序
    int i = 0; 
    while (A[i].weight < weight) {
        A[i].choose = true;
        weight -= A[i].weight;
        value += a[i].value;
        ++i;
    }
    if (i < A.size() && weight > 0) {
        A[i].choose = weight / A[i].weight;
        value += A[i].choose * A[i].value;
    }
    return value;
}
```

#### 最优装载

[问题描述] 有 $n$ 个集装箱要装上一艘载重量为 $W$ 的轮船，其中集装箱 $i(1\le i\le n)$ 的重量为 $w_i$。不考虑集装箱的体积限制，现要选出尽可能多的集装箱装上轮船，使它们的重量之和不超过 $W$。

[贪心策略] 当重量限制为 $W$ 时，$w_i$ 越小可装载的集装箱个数越多，所以采用**优先选取重量轻**的集装箱装船。

```cpp
struct Box {
	int w{};
    bool choose{};
    
    bool operator<(const Box& that) { return w < that.w; }
};

int solve(std::vector<Box>& w, const int W) {
    std::sort(w.begin(), w.end());
    int maxw = 0;
    int restw = W; // 剩余重量
    for (int i{1}; i <= n && w[i].w <= restw; ++i) {
        w[i].choose = true;
        restw -= w[i].w;
        maxw += w[i].w;
    }
    return maxw;
}
```

#### 田忌赛马

[问题描述] 现在田忌和齐威王各 $n$ 匹马，依次派出一匹马进行比赛，每一轮获胜的一方将从输的一方得到 200 银币，平局则不用出钱，田忌已知所有马的速度值并可以安排出场顺序，问他如何安排比赛获得的银币最多？

[贪心策略] 分情况讨论

1. 田忌最快马 > 齐威王最快马，则二马相比田忌胜。
2. 田忌最快马 < 齐威王最快马，田忌选择最慢马与齐威王最快马比，田忌输。
3. 田忌最快马 = 齐威王最快马
   - 田忌最慢马 > 齐威王最慢马，则二马相比田忌胜。
   - 田忌最慢马 < 齐威王最慢马，田忌选择最慢马与齐威王最快马比，田忌输。
   - 其他情况，平局。

```cpp
int sovle(std::vector<int>& a, std::vector<int>& b) {
    // a：田忌；b：齐王
    std::sort(a.begin(), a.end());
    std::sort(b.begin(), b.end());
    int coin = 0;
    int lefta = 0, letfb = 0; // 田忌和齐王的最慢马
    int righta = a.size() - 1, rightb = b.size() - 1; // 最快马
    
    while (lefta <= righta) { // 当有马的时候
        if (a[righta] > b[rightb]) { 
            coin += 200;
            --righta;
            --rightb;
        } else if (a[righta] < b[rightb]) {
            coin -= 200;
            ++lefta;
            --rightb;
        } else if (a[lefta] > b[leftb]) {
            coin += 200;
            ++lefta;
            ++letfb;
        } else {
            if (a[lefta] < b[leftb]) {
                coin -= 200;
            }
            ++lefta;
            --rightb;
        }
    }
    return coin;
}
```

#### 多机调度

[问题描述] 设有 $n$ 个独立的作业 $\{1, 2,\cdots, n\}$，由 $m$ 台相同的机器 $\{1, 2, \cdots, m\}$ 进行加工处理，作业 $i$ 所需的处理时间为 $t_i(1\le i\le n)$，每个作业均可在任何一台机器上加工处理，但未完工前不允许中断，任何作业也不能拆分成更小的子作业。多机调度问题要求给出一种作业调度方案，使所给的 $n$ 个作业在尽可能短的时间内由 $m$ 台机器加工处理完成。

[贪心策略] 让**最长处理时间的作业优先**，即把**处理时间最长的作业分配给最先空闲的机器**，这样可以保证处理时间长的作业优先处理，从而在整体上获得尽可能短的处理时间。 => **按照处理时间排序**

```cpp
struct Task {
	int number{};
    int time{};
    int machine{};
    
    bool operator<(const Task& that) { return time < that.time; }
};

void solve(std::vector<Task>& A) {
    if (n <= m) {
        std::cout << "为每一个作业分配一个机器\n";
        return;
    }
    std::sort(A.begin(), A.end(), std::greater<>()); // 从大到小排序
    std::priority_queue<Task,  std::greater<>> pq; // 小根堆(每次选择当前最早空闲的机器)
    for (int i{}; i < m; ++i) {
        A[i].machine = i + 1; // 给机器编号(从1开始)
        std::cout 
            << "给机器" << A[i].machine << "分配作业" << A[i].number
            << ", 执行时间为" << A[i].time 
            << "占用时间段[0, " << A[i].time << "]\n";
        pq.push(A[i]);
    }
    for (int j = m; j < n; ++j) {
        auto t = pq.top(); // 获取当前最早空闲的机器
        pq.pop();
        std::cout           
            << "给机器" << t.machine << "分配作业" << A[j].number
            << ", 执行时间为" << A[j].time 
            << "占用时间段[" << t.time << ", " << t.time + A[j].time << "]\n";
        t.time += A[j].time;
        pq.push(t);
    }
}
```

#### 哈夫曼编码

[问题描述] 设需要编码的字符集为 $\{d_1, d_2,\cdots, d_n\}$，它们出现的频率为 $\{w_1, w_2,\cdots, w_n\}$，应用哈夫曼树构造最优的不等长的由 0、1 构成的编码方案。

[贪心策略] 每次选择权值最小和次小的两个结点作为左右子树构造一个二叉树，新二叉树的根结点权值为左右子树根结点的权值之和。

带权路径长度：

$$
\symup{WPL} = \sum_{i = 1}^n w_i\times l_i
$$

其中 $l_i$ 为第 $i$ 个叶子结点的路径长度。

**$n$ 个字符得到的哈夫曼树有 $2n - 1$ 个结点**。

```cpp
struct HuffmanNode {
    char data;          // 字符
    int freq;           // 频率
    HuffmanNode* left;  // 左子节点
    HuffmanNode* right; // 右子节点
    
    HuffmanNode(char d, int f) : data(d), freq(f), left(nullptr), right(nullptr) {}
   
    bool operator<(const HuffmanNode& that) const {
        return freq < that.freq;
    }
};

HuffmanNode* buildHuffmanTree(const unordered_map<char, int>& freqMap) {
    vector<HuffmanNode*> nodes;
    
    // 创建叶子节点
    for (auto& pair : freqMap) {
        nodes.push_back(new HuffmanNode(pair.first, pair.second));
    }
    
    // 构建哈夫曼树
    while (nodes.size() > 1) {
        // 按频率排序（升序）
        sort(nodes.begin(), nodes.end(), 
             [](HuffmanNode* a, HuffmanNode* b) { return *a < *b; });
        
        // 取出两个最小频率的节点
        HuffmanNode* left = nodes[0];
        HuffmanNode* right = nodes[1];
        
        // 创建新节点，频率为两个子节点频率之和
        HuffmanNode* newNode = new HuffmanNode('$', left->freq + right->freq);
        newNode->left = left;
        newNode->right = right;
        
        // 删除已合并的节点，添加新节点
        nodes.erase(nodes.begin(), nodes.begin() + 2);
        nodes.push_back(newNode);
    }
    
    return nodes[0];
}
```



#### 流水作业调度问题

[问题描述] 有 $n$ 个作业（编号为 1~$n$）要在由两台机器 $M_1$ 和 $M_2$ 组成的流水线上完成加工，每个作业加工的顺序都是先在 $M_1$ 上加工，然后在 $M_2$ 上加工，$M_1$ 和 $M_2$ 加工作业 $i$ 所需的时间分别为 $a_i$ 和 $b_i(1\le i\le n)$。

[贪心策略] Johnson 算法

1. 把所有作业按 $M_1$、$M_2$ 的时间分为两组，$a[i]\le b[i]$ 对应第一组 $N_1$，$a[i] > b[i]$ 对应第 0 组 $N_2$。
2. 将 $N_1$ 的作业按 $a[i]$ 递增排序，$N_2$ 的作业按照 $b[i]$ 递减排序。
3. 按顺序先执行 $N_1$ 的作业，再执行 $N_2$ 的作业。

```cpp
struct Task {
    int number{};
    int time{};
    bool group{}; // 分组标识 (a <=b: true; a > b：false) 
    
    bool operator<(const Task& that) const { return time < that.time; }
};

int solve(const std::vector<int>& a, const std::vector<int>& b, std::vector<Task>& best) {
    const int n = a.size();
    std::vector<Task> c(n);
    for (int i{}; i < n; ++i) {
        c[i].number = i;
        c[i].group = a[i] <= b[i];
        c[i].time = c[i].group ? a[i] : b[i];
    }
    std::sort(c.begin(), c.end());
    int j = 0, k = n - 1;
    for (int i{}; i < n; ++i) {
        if (c[i].group) {
            best[j++] = c[i].number;
        } else {
            best[k--] = c[i].number;
        }
    }
    int f1 = 0, f2 = 0;
    for (int i{}; i < n; ++i) {
        f1 += a[best[i]]; // 机器A上的累计时间
        f2 = std::max(f2, f1) + b[best[i]]; // 机器B上的完成时间
    }
    return f2;
}
```

> 能够熟练判断某问题是否能用贪心法求解

满足贪心选择性质、最优子结构性质就行，没有技巧可言。

### 课后题

见 [题目文档](./贪心.pdf)。

## 动态规划

### 动态规划概述

> 动态规划法的原理、采用动态规划方法求解的问题的 3 个性质

基本思想：动态规划是一种解决多阶段决策问题的优化方法，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。

基本思路：将待求解问题分解成若干个子问题，先求子问题的解，然后从这些子问题的解得到原问题的解。

基本概念：

1. 阶段和阶段变量：一个问题被分成若干个阶段，每个阶段用阶段变量 $k$ 表示。
2. 状态和状态变量：描述决策过程当前特征的量称为**状态**，它可以是数量，也可以是字符。每一状态可以取不同值，状态变量记为 $s_k$，各阶段所有状态组成的集合称为状态集，用 $S_k$ 表示，有 $s_k\in S_k$。在决策过程中，每一个阶段只选取一个状态，$s_k$ 表示第 $k$ 阶段所取的状态。各阶段的状态为上一阶段的结束点，或该阶段的起点组成的集合。
3. 决策和策略：决策就是决策者在过程处于某一阶段的某一状态时面对下一阶段的状态做出的选择或决定。策略就是策略者从第 1 阶段到最后阶段的全过程的决策构成的决策序列。第 $k$ 阶段到最后阶段的决策序列称为子策略。
4. 状态转移方程：某一状态以及该状态下的决策与下一状态之间的指标函数之间的关系称为状态转移方程，其中指标函数是衡量对决策过程进行控制的效果的数量指标，可以是收益、成本或距离等。一般在求最优解时指标函数对应的是最优指标函数。

性质：

1. 最优性原理：问题的最优解所包含的子问题的解也是最优的。

2. 无后效性：某阶段的状态一旦确定，就不受这个状态以后决策的影响。
3. 有重叠子问题：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次用到。

> 动态规划法与分治法、贪心法的联系与区别

| 方法         | 联系                                                         | 区别                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 动规与分治法 | 待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 | （1）适合用动态规划法求解的问题，分解得到的各子问题往往不是相互独立的(重叠子问题性质)，而分治法中的子问题相互独立；<br />（2）动态规划法用表保存已求解过的子问题的解，再次碰到同样的子问题时不必重新求解，只需查询答案，故可获得多项式级时间复杂度，效率较高；而分治法中对于每次出现的子问题均求解，导致同样的子问题被反复求解，故产生指数增长的时间复杂度，效率较低。 |
| 动规与贪心法 | 都要求问题具有最优子结构性质。                               | （1）求解方式不同，动态规划法是自底向上的，有些具有最优子结构性质的问题只能用动态规划法，有些可用贪心法；而贪心法是自顶向下的。<br/>（2）对子问题的依赖不同, 动态规划法依赖于各子问题的解，所以应使各子问题最优才能保证整体最优；而贪心法依赖于过去所做过的选择，但决不依赖于将来的选择，也不依赖于子问题的解。 |

### 动态规划的应用

> 会用动态规划法求解整数拆分（备忘录方法与动规异同）、最大连续子序列和（可采用的方法有哪些？）、最长公共子序列 LCS、最长递增子序列、编辑距离、0/1 背包及完全背包、三角形最小路径、资源分配、会议安排问题

$$
\renewcommand{\dp}{\symup{dp}}
$$

#### 整数拆分

[问题描述] 求将正整数 $n$ 无序拆分成最大数为 $k$ 的拆分方案个数，要求所有的拆分方案不重复。

[转移方程] 用 $\dp[i][j]$ 表示将数 $n$ 无序拆分成最多不超过 $k$ 个数之和的分方案个数：

$$
\dp [i][j] = \begin{cases}
 1 & , i = 1\ \text{or}\ j = 1 \\
 \dp [i][i] & , i < j \\
 \dp [i][i - 1] + 1 & , i = j \\
 \dp [i - j][j] + \dp [i][j - 1] & , \text{others}
\end{cases}
$$

所求答案：$\dp[n][k]$


```cpp
// 备忘录
std::array<std::array<int, MAXN>, MAXN> dp;
void dpfunc(int n, int k) {
    if (dp[n][k] != 0) {
        return dp[n][k];
    }
    if (n == 1 || k == 1) {
        return dp[n][k] = 1;
    }
    if (n < k) {
        return dp[n][k] = dpfunc(n, n);
    }
    if (n == k) {
        return dp[n][k] = dpfunc(n, n - 1) + 1;
    }
    return dp[n][k] = dpfunc(n, k - 1) + dpfunc(n - k, k);
}
```

备忘录方法与动规异同:

| 方法       | 相同                  | 不同     |
| ---------- | --------------------- | -------- |
| 备忘录方法 | 相同子问题只计算一次… | 自顶向下 |
| 动态规划   | 相同子问题只计算一次… | 自底向上 |

#### 最大连续子序列和

[问题描述] 给定一个有 $n\ge 1$ 个整数的序列，求出其中最大连续子序列的和。

[转移方程] 用 $\dp[i]$ 表示 $a[0..i]$ 中最大的连续子序列和：

$$
\dp [i] = \begin{cases}
 0 & , i = 0 \\
 \max\qty(\dp [i - 1] + a_i, a_i) & , 1\le i\le n
\end{cases}
$$

所求答案：$\dp[n - 1]$

[时间复杂度] $O(n)$

#### 最长公共子序列

[问题描述] 给定两个序列 $A$ 和 $B$，称序列 $Z$ 是 $A$ 和 $B$ 的公共子序列是指 $Z$ 同是 $A$ 和 $B$ 的子序列。求两序列 $A$ 和 $B$ 的最长公共子序列

[转移方程] 用 $\dp[i][j]$ 表示子序列 $A[0..i - 1]$ 和 $B[0..j - 1]$ 的最长公共子序列长度

$$
\dp [i][j] = \begin{cases}
 0 &, i = 0 \text{or} j = 0 \\
 \dp [i  - 1][j - 1] + 1 &, a [i - 1] = b [j - 1] \\
 \max\qty(\dp [i][j - 1], \dp [i - 1][j]) &, \text{others}
\end{cases}
$$

所求答案：$\dp[m][n]$

[时间复杂度] $O(mn)$

#### 最长递增子序列

[问题描述] 给定一个无序的整数序列 $a[0..n - 1]$，求其中最长递增子序列的长度。

[转移方程] 用 $\dp[i]$ 表示 $a[0..i]$ 中以 $a[i]$ 结尾的最长递增子序列长度

$$
\dp [i] = \begin{cases}
 1 &, 0\le i\le n - 1 \\
 \max\limits_{0\le j\le i - 1}\qty(\dp [i], \dp [j] + 1) &, a [i] > a [j], 0\le i\le n - 1
\end{cases}
$$

所求答案：$\max\limits_{0\le i\le n - 1}\qty{\ \dp[i]\ }$

[时间复杂度] $O(n^2)$

#### 编辑距离

[问题描述] 设 $A$ 和 $B$ 是两个字符串，现在要用最少的字符操作次数将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有以下 3 种：

1. 删除一个字符；
2. 插入一个字符；
3. 将一个字符替换为另一个字符；

[转移方程] 用 $\dp[i][j]$ 表示 $A[0..i - 1]$ 和 $B[0..j - 1]$ 的最优编辑距离

$$
\dp [i][j] = \begin{cases}
 i &, j = 0 \\
 j &, i = 0 \\
 \dp [i - 1][j - 1] &, a [i - 1] = b [j - 1] \\
 \min\qty(\dp [i - 1][j - 1], \dp [i][j - 1], \dp [i - 1][j]) + 1 &, a [i - 1] \ne b [j - 1]
\end{cases}
$$

所求答案：$\dp[m][n]$

[时间复杂度] $O(mn)$

#### 0/1 背包

[问题描述] 有 $n$ 个重量分别为 $w_1$、$w_2$、$\cdots$、$w_n$ 的物品（物品编号为 1~$n$），它们的价值分别为 $v_1$、$v_2$、$\cdots$、$v_n$，给定一个容量为 $W$ 的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且具有最大的价值。

[转移方程] 用 $\dp[i][j]$ 表示背包容量为 $j(1\le j\le W)$ 时已经考虑物品 1、2、…、$i(1\le i\le n)$ 时背包装入物品的最优价值。

$$
\dp [i][j] = \begin{cases}
 0 &, i = 0\ \text{or}\ j = 0 \\
 \dp [i - 1][j] &, j < w [i] \\
 \max\qty(\dp [i - 1][j], \dp [i - 1][j - w[i]] + v [i]) &, \text{others}
\end{cases}
$$

所求答案：$\dp[n][W]$

[时间复杂度] $O(nW)$。

#### 完全背包

[问题描述] 有 $n$ 种重量和价值分别为 $w_i、v_i\qty(0\le i < n)$ 的物品，从这些物品中挑选总重量不超过 $W$ 的物品，求出挑选物品价值总和最大的方案，这里每种物品可以挑选任意多件。

[转移方程] 用 $\dp[i][j]$ 表示从前 $i$ 个物品中取出重量不超过 $j$ 的物品的最大总价值，令设 $\symup{fk}[i][j]$ 存放 $\dp[i][j]$ 得到最大值时物品 $i$ 挑选的数量。

$$
\dp [i][j] = \begin{cases}
 0 &, i = 0\ \text{or}\ j = 0 \\
 \max\limits_{k * w [i] \le j}\qty(\dp [i - 1][j - k * w[i]] + k * v [i]) &, \text{dp[i][j] < dp[i-1][j-k * w[i]] + k * v[i]}
\end{cases} \\
\symup{fk}[i][j] = k
$$

k:物品i取k个。

所求答案：$\dp[n][W]$

[时间复杂度] $O(nW^2)$

#### 三角形最小路径

[问题描述] 给定高度为 $n$ 的一个整数三角形，找出从顶部到底部的最小路径和，注意从每个整数出发只能向下移动到相邻的整数。

[转移方程] 用 $\dp[i][j]$ 表示从顶部 $a[0][0]$ 查找到 $(i, j)$ 结点时的最小路径和：

$$
\dp [i][j] = \begin{cases}
     a [0][0] &, i = 0\ \text{and}\ j = 0 \\
     \dp [i - 1][0] + a [i][0] &, 1\le i\le n - 1\ \text{and}\ j = 0 \\
     \dp [i - 1][i - 1] + a [i][i] &, i = j \\
     \min\qty(\dp [i - 1][j - 1], \dp [i - 1][j]) + a [i][j] &, \text{others}
\end{cases}
$$

所求答案：$\min\limits_{1\le j < n}\qty{\dp[n - 1][j]}$，$(n - 1, j)$

[时间复杂度] $O(n^2)$

#### 资源分配

[问题描述] 资源分配问题是将数量一定的一种或若干种资源（原材料、资金、设备或劳动力等）合理地分配给若干个使用者，使总收益最大。

[转移方程] 用 $\dp[i][s]$ 表示考虑商店 $i$ 到商店 $m$(共$m$个使用者) 并分配总共 $s$ 个人后的最优盈利，另设 $\symup{pnum}[i][s]$ 表示求出 $\dp[i][s]$ 时对应商店 $i$ 的分配人数。

$$
\dp [i][s] = \begin{cases}
 0 &, i = m + 1 \\
 \max\limits_{0\le j\le n}\qty(v [i][j] + \dp [i + 1][s - j]) &, \symup{pnum [i][s]} = \dp [i][s]取最大值的j
\end{cases}
$$

所求答案：$\dp[1][n]$

[时间复杂度] $O(mn^2)$

#### 会议安排问题

[问题描述] 陈老师是一个比赛队的主教练。有一天，他想给团队成员开会，应该为这次会议安排教室，但教室非常缺乏，所以教室管理员必须通过接受订单和拒绝订单优化教室的利用率。如果接受一个订单，则该订单的开始时间和结束时间成为一个活动。注意，每个时间段只能安排一个订单（即假设只有一个教室）。请找出一个最大化的总活动时间的方法。

[转移方程] 先把订单 $A[0..n - 1]$ 按**结束时间**递增排序，用 $\dp[i]$ 表示 $A[0..i]$ 的订单中所有兼容订单的最长时间。

$$
\dp [i] = \begin{cases}
 A[0].length() &, i = 0 \\
 \max\qty(\dp [i - 1], \dp [j] + A [i].\symup{length}) &, A [j].\symup{end} \preceq A [i].\symup{begin}
\end{cases}
$$

所求答案：$\dp[n - 1]$

[时间复杂度] $O(n\log n)$

> 能够熟练判断某问题是否能用动态规划法求解、能够熟练写出状态转移方程

没办法，菜就多练。

### 滚动数组

> 了解什么是滚动数组及应用场合

在动态规划算法中常用动态规划数组存放子问题的解，由于一般是存放连续的解，有时可以对数组的下标进行特殊处理，使每一次操作仅保留若干个有用信息，新的元素不断循环刷新，看上去数组的空间被滚动利用，这样的数组称为滚动数组

其主要目的是**压缩存储空间**。实际上，滚动数组应用的条件是**基于递推或递归的状态转移中**，反复调用当前状态前的几个阶段的若干个状态，而**每一次状态转移后有固定个数的状态失去作用**。滚动数组便是**充分利用了那些失去作用的状态的空间**填补新的状态，一般采用求模方法实现滚动数组。

### 课后题

见 [题目文档](./动态规划.pdf)。

## 图算法

### 最小生成树

> 掌握 Prim 算法和 Kruskal 算法的思路、异同点、应用场合以及时间复杂度

#### Prim 算法思路

1. 初始化 $U  = \{v\}$，以 $v$ 到其他顶点的所有边为侯选边。
2. 重复以下步骤 $n - 1$ 次，使得其他 $n - 1$ 个顶点被加入到 $U$ 中。
   - 以顶点集 $U$ 和顶点集 $V - U$ 之间的所有边作为侯选边，从中挑选权值最小的边，加入 $TE$，设该边 $V - U$ 中的顶点是 $k$，将 $k$ 加入 $U$ 中。
   - 考察当前 $V - U$ 中所有顶点 $j$，修改侯选边，若 $(k, j)$ 的权值小于原来和顶点 $j$ 关联的侯选边，则用 $(k, j)$ 取代后者作为侯选边。

#### Kruskal 算法思路

1. 初始化 $U = V$, $TE = \empty$
2. 将图 $G$ 中的边按权值从小到大的顺序依次选取，若选取的边未使生成树 $T$ 形成回路，则加入 $TE$，否则舍弃，直到 $TE$ 中包含 $n - 1$ 条边为止。

#### 二者对比

相同点：贪心，构造性算法

| 算法    | 不同点                 | 应用场合               | 时间复杂度   |
| ------- | ---------------------- | ---------------------- | ------------ |
| Prim    | 点优先                 | 稠密图（边多是稠密图） | $O(n^2)$     |
| Kruskal | 边优先、并查集判断回路 | 稀疏图（边少是稀疏图） | $O(e\log e)$ |

> 会利用两种算法手工构造 MST

手工构建，不多说。

> 能看懂两种算法的实现代码

略。

### 图的最短路径

> 掌握 Dijkstra 算法、Bellman-ford 算法、Floyd 算法的思路、异同点、应用场合以及时间复杂度

#### Dijkstra 算法思路

基本思想：设 $G = (V, E)$ 是一个带权有向图，把图中顶点集合 $V$ 分成两组：

1. 第 1 组为已求出最短路径的顶点集合（用 $S$ 表示，初始时 $S$ 中只有一个源点，以后每求得一条最短路径 $v, \cdots, u$，就将 $u$ 加入到集合 $S$ 中，直到全部顶点都加人到 $S$ 中，算法就结束了）
2. 第 2 组为其余未确定最短路径的顶点集合（用 $U$ 表示），按最短路径长度的递增次序依次把第 2 组的顶点加入到 $S$ 中。

具体步骤：

1. 初始时 $S$ 只包含源点，即 $S=\{v\}$，顶点到自己的距离为 O。$U$ 包含除 $v$ 以外的其他顶点，$v$ 到 $U$ 中顶点 $i$ 的距离为边上的权（若 $v$ 与 $i$ 有边 $<v, i>$）或 $\infty$（若 $i$ 不是 $v$ 的出边邻接点）。
2. 从 $U$ 中选取一个顶点 $u$，顶点 $v$ 到顶点 $u$ 的距离最小，然后把顶点 $u$ 加人到 $S$ 中（该选定的距离就是 $v$ 到 $u$ 的最短路径长度）。
3. 以顶点 $u$ 为新考虑的中间点，修改顶点 $v$ 到 $U$ 中各顶点的距离：若从源点 $v$ 到顶点 $j(j\in U)$ 经过顶点 $u$ 的距离比原来不经过顶点 $u$ 的距离短，则修改从顶点 $v$ 到顶点 $j$ 的最短距离值。
4. 重复步骤（2）和（3），直到 $S$ 包含所有的顶点。

#### Bellman-ford 算法思路

构造一个最短路径长度数组序列 $\symup{dist}^0[u], \symup{dist}^1[u], \cdots, \symup{dist}^{n - 1}[u]$

1. $\symup{dist}^0[u]$ 是初始化结果：若源点 $v$ 到顶点 $u$ 有边，则 $\symup{dist}^0[u] = \symup{edges}[v][u]$，否则 $\symup{dist}^0[u] = \infty$。
2. $\symup{dist}^{i}[u]$ 为源点 $v$ 出发最多经过不构成负权值回路的 $i$ 条边到达终点 $u$ 的最短路径长度。

算法的最终目的是求出 $\symup{dist}^{n - 1}[u]$，对应的递推关系式为：

$$
\symup{dist}^0 [u] = g.\symup{edges}[v][u] \\

\symup{dist}^k [u] = \min\limits_{0\le i\le n - 1, i \ne u}\qty(
 \symup{dist}^k [u],
 \symup{dist}^{k - 1}[i] + \symup{edges}[i][u]
)
$$

#### Floyd 算法思路

Floyd 算法基于动态规划，采用 $\dp[i][j]$ 表示从当前顶点 $i$ 到顶点 $j$ 的最短路径长度，$\dp_k[i][j]$ 表示从当前顶点 $i$ 到顶点 $j$ 的路径上所经过的顶点编号不大于 $k$ 的最短路径长度。

其状态转移方程：

$$
\dp_{-1}[i][j] = \symup{edges}[i][j] \\
\dp_k [i][j] = \min\limits_{0\le k\le n - 1}\qty(\dp_{k - 1}[i][j], \dp_{k - 1}[i][k] + \dp_{k - 1}[k][j])
$$

#### 三者对比

相同点：都用于求解最短路径问题（Dijkstra 和 Bellman-ford 算法是单源，Floyd 算法是多源），不能处理负权回路（问题无解，Bellman-ford 和 Floyd 算法都允许负权边），Bellman-ford 和 Floyd 可以检测是否存在负权回路。

| 算法         | 不同点       | 应用场合                         | 时间复杂度 |
| ------------ | ------------ | -------------------------------- | ---------- |
| Dijkstra     | 贪心         | 不含有负权的图求单源最短路径     | $O(n^2)$   |
| Bellman-ford | 类似滚动数组 | 不含有负权回路的图求单源最短路径 | $O(ne)$    |
| Floyd        | 动态规划     | 不含有负权回路的图求多源最短路径 | $O(n^3)$   |

> 能看懂三种算法的实现代码

略。

## 计算复杂性理论

### 计算模型

> 图灵机的概念，能根据设计好的图灵机看懂瞬像演变过程

图灵机模型的基本结构包含一条无限向右延伸的输入带（可读可写）、一个有限状态控制器和连接控制器和输入带的读写头。输入带由一个个格组成，每一格可以存放一个字符。

当图灵机的读写头扫描到一个格的字符时，根据控制器的当前状态和扫描到的字符决定图灵机的动作，包括 3 个方面，即控制器进行状态转换（决定下一状态）、读写头在当前格上写上新的字符、决定读写头向左或向右移动一格。

设当前瞬像为 $x_1\cdots x_{i - 1}\symbf{q}x_i\cdots x_n$，表示当前状态为 $q$，读写头正注视着 $x_i$ 字符

若 $\delta(q, x_i) = (p, y, L)$，则当 $i > 1$ 时有：

$$
x_1\cdots x_{i - 1}\symbf qx_i\cdots x_n \mapsto x_1\cdots x_{i - 2}\symbf px_{i - 1}yx_{i + 1}\cdots x_n
$$

若 $\delta(q, x_i) = (p, y, R)$，则有：

$$
x_1\cdots x_{i - 1}\symbf qx_i\cdots x_n \mapsto x_1\cdots x_{i - 1}y\symbf{p}x_{i + 1}\cdots x_n
$$

例一：

<img src=".\assets\例一.png" alt="例一" style="zoom:50%;" />

其对应的状态转化图:

<img src=".\assets\状态转化图.png" alt="状态转化图" style="zoom: 50%;" />

例二：

<img src=".\assets\例二.png" alt="例二" style="zoom: 50%;" />

> 了解停机问题与判定性的概念

图灵机的状态：

- 进入终止状态，这时 $M$ 停机，并接受 $w$
- 未进入终止状态，但是 $\delta$ 无定义，此时 $M$ 停机，不接受 $w$
- 一直不进入终止状态，且 $\delta$ 一直有定义，此时 $M$ 永不停机

若一个语言被一个图灵机 $M$ 接受，且对于任意的输入串 $w$，$M$ 都停机，称之为递归语言（可计算语言）。

**判定问题**：对于一系列无限集合上的输入值，该问题是否能利用某种方法来回答是或否？

**可判定性**：某个判定问题存在一个算法，使得对于该问题的每个输入都能回答是或否，那么该问题是可判定的。

**停机问题**：是可计算性理论中的一个问题，它是一个判定问题，即：对于任意一个程序 $P$ 和任意一个输入 $I$，该程序是否能够终止运行？

### 关于 P、NP、NPC

> 什么是 P、NP、NPC 问题，他们之间的关系

- P 类问题：在多项式时间内**既可求解也可验证解**的问题。
- NP 类问题：在多项式时间**可验证解**的问题。
- NPC 类问题：本身是 NP 问题，且所有的 NP 问题都可以在多项式时间内归约到这个问题。

$$
\symup{P} \subseteq \symup{NP} \\
\symup{NPC} \subseteq \symup{NP} \\
\symup{P} \overset{\text{?}}{=} \symup{NP}
$$

> P 类和 NP 类问题与图灵机的关系（标准定义）

- P 类问题：用**确定性图灵机以多项式时间界可解**的问题。
- NP 类问题：**非确定性图灵机上具有多项式算法**的问题。

> 知道什么是 TSP 问题

给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。（即求解最小费用的哈密顿回路）

> 会求解前面章节涉及算法的时间复杂度，并判断其属于 P 类还是 NP 类问题

简单。

> 课后选择题要会做

1. 旅行商问题是NP问题吗？
    A. 否          B. 是          C. 至今尚无定论
2. 下面有关 P 问题、NP 问题和 NPC 问题，说法错误的是（ ）。
    A. 如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题
    B. NP 问题是指可以在多项式的时间里验证一个解的问题
    C. 所有的 P 类问题都是 NP 问题
    D. NPC 问题不一定是 NP 问题，只要保证所有的 NP 问题都可以约化到它即可

<details>
    <summary>答案</summary>
    <div><b>1. B</b></div>
    <div><b>2. D</b></div>
</details>


## 概率算法和近似算法

### 概率算法

> 四种概率算法的特点和应用场景

- 平均期望时间：所有输入实例上平均的期望执行时间

- 最坏期望时间：最坏的输入实例上的期望执行时间

| 概率算法       | 特点                                                         | 应用场景                                                     |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数值概率算法   | 用于数值问题的求解，得到最优化问题的近似解，精度随计算时间的增加不断提高。 | 数值问题的求解                                               |
| 蒙特卡罗算法   | 判定问题的精确解，得到的解不一定正确                         | 近似计算（如圆周率估算）、随机模拟（如金融风险评估）、NP 问题近似求解 |
| 拉斯维加斯算法 | 不一定会得到解，但得到的解一定是正确解                       | 精确搜索、密码学质数判定、组合优化验证                       |
| 舍伍德算法     | 总能求得一个解，且一定是正确解                               | 一个确定性算法的最坏时间复杂度与平均时间复杂度存在较大差异   |

### 近似算法

> 了解近似算法概念，可以用来求解哪些经典问题

近似算法通常和 NP 问题相关，由于目前不可能采用有效的多项式时间精确地解决 NP 问题，所有采用多项式时间求一个次优解。

旅行商问题（TSP）、最小顶点覆盖、集合覆盖

> 课后选择题要会做

![概率算法与近似算法](.\assets\概率算法与近似算法.png)

<details>
    <summary>答案</summary>
    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
        <div style="flex: 0 0 30%;"><b>1. C</b></div>
        <div style="flex: 0 0 30%;"><b>2. B</b></div>
        <div style="flex: 0 0 30%;"><b>3. A</b></div>
        <div style="flex: 0 0 30%;"><b>4. D</b></div>
        <div style="flex: 0 0 30%;"><b>5. C</b></div>
        <div style="flex: 0 0 30%;"><b>6. D</b></div>
        <div style="flex: 0 0 30%;"><b>7. C</b></div>
    </div>
</details>


7D:舍伍德算法是为了消除或减少好坏实例之间**在执行时间性能**上的差别。
