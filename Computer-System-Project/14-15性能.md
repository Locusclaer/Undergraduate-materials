# 性能
## 引言
**设计目标之一**

计算机系统显式或隐含了性能目标

**性能的意义是什么？**

性能是计算机的货币

性能是有代价（复杂性、并发冲突）的

**性能工程的意义**
1. 摩尔定律不再有效
2. 性能工程不只是一点点提升

### 性能工程的关键问题：瓶颈
**什么是瓶颈？**
- 瓶颈 = 系统中最慢的环节
- 未经性能优化的系统，通常都**存在瓶颈**

**性能工程的关键**

- **消除瓶颈**
- 尽可能保持模块化、避免复杂性增长

**性能瓶颈是怎么产生的?**

1. > 各种限制导致技术维度发展不均衡

**物理**

- 光速限制（计算、访存、通信:后者无法匹配前者的速度）
- 功率限制、散热限制

*绕过限制时，经常遇到冲突*

**技术**

- 目前图同构最好的算法时间复杂度是$O(2^n)$
- 目前排序最好的算法时间复杂度是$O(nlogn)$
- 目前大数分解最好的算法时间复杂度是$O(2^n)$

2. > 共享使性能变成了一个多目标问题

很多组件共享同一资源(存储、通信、计算等)

**共享的多种目标：**

- 总体利用率最高
- 平均等待最短
- ……

无论采取何种目标，优先级低低组件的请求成为瓶颈

### 性能设计中的矛盾
1. >  是否投入成本进行性能设计

**难题：如何判断性能优化在技术进步下是否有价值？**

**设计经验1:迟疑时，诉诸暴力**

- 选择简单的算法，等待复杂的算法的成熟和稳定
- 选择简单硬件堆叠，等待技术发展带来新硬件
    - 暴力搜索的高性能象棋程序战胜人类选手
    - 暴力堆叠的大模型围棋程序战胜人类选手

2. >  性能设计带来的问题如何解决?

**主要问题：复杂性提升**

**采取KIS原则(Keep It Simple)和两种设计方法:**

1. 抽象方法
- 通过抽象可以隐藏实现、保持模块化
2. 接口保持方法
- 组件性能多样性(如存储)，通过接口保持，保持简单性

总结：

性能是一定成本/时间下的收益

性能工程的意义:收益客观，弥补摩尔定律

## 性能指标
**计算机系统工作场景：**
- C/S架构:模块化，请求/服务，时间与数量

**主要性能指标：**

1. 容量：提供多少

**容量 = 服务提供的资源的大小或数目**

2. 利用率：有无浪费

**利用率：服务资源用于给定工作负载的比例**

3. 时延：等待多久

**时延：开始和结束之间的时间差**

**串行任务/流水线时延：**
- A + B 的时延 ≥ 时延 A + 时延 B

4. 吞吐率：处理多快

**吞吐率：完成有用工作的速率**

串行任务吞吐率：
- A + B 的吞吐率 ≤ minimum\{吞吐率A,吞吐率B\}
- **限制了快速部件的利用率**

### 吞吐率与时延的关系
**串行处理时：**

- （最大）吞吐率 = 1 / （处理）时延

**并行处理时：**

- 没有直接关系

吞吐率和时延哪个更容易提升？

吞吐率——购买更多服务器、带宽

时延——你不能改变物理定律:光速、CPU频率

**串行结构：**

- 时延大于组件时延的总和

- 吞吐率小于最慢组件的吞吐率

- 时延与最大吞吐率成反比

- 排队时延在达到最大吞吐率时开始产生

**并行结构：**

- 时延与吞吐率无关

## 性能优化流程
**系统化方法：**

1. 通过测量、分析、计算、找到瓶颈
2. 提升瓶颈模块的性能
3. 迭代

- 牢记**收益递减法则**
- 如果收益递减、难以达成目标，**重新审视系统的设计**

## 优化设计方法
### 结构优化
**减少时延的思路**
- 单个部件/请求的时延难以减少
- 多个部件/请求的平均时延可以减少

1. 基于工作负载
- 快路径/慢路径（基于非均匀性）：为常见的操作提供快路径

**设计经验2:优化高频用例**
- 计算机存储：多级存储
- 设计提示：有存储抽象的地方都可以使用该策略

*收益：*
平均时延（各类情况时延的频率加权平均）下降

2. 并行

**并行对于程序执行效果的提升实际小于设想：**
- 不完全化并行：子任务依赖、资源共享
- 并行化的开销：模块间通信交换中间结果
- 并行不平衡：存在快/慢路径

**并行化的挑战**
- 很多应用难以实现并行化
- 实现并行化的复杂性

3. 交叠

**如果只有串行资源（例如处理器），那么前两个策略不适用**
- 快路径/慢路径策略不适用
- 步骤之间有依赖
- 步骤拆分成子步骤，子步骤之间也有**强**依赖

不严格依赖：第一个步骤不依赖于上一步骤的最后一个子步骤

可以使用交叠（或流水线）—— 优点：不需要增加服务能力

![alt text](image.png)

**交叠的特点：隐藏时延，提升吞吐率**
- 如可拆分为并行子步骤，减少时延 → 提升吞吐率
- 交叠拆分为串行子步骤，隐藏时延 → 提升吞吐率

**设计经验3:时延难以减少，隐藏时延**
- **处理器**的多级流水线
- **分布式计算**的传输与计算交叠
- **浏览器**对页面分时加载（显示与传输交叠）

**交叠面临的挑战**
1. 子模块的工作均衡问题
   - 有的模块跟不上进度
   - 缓解：子模块间的有界缓冲区
2. 需要有多个并发的请求
   - 如何并发？
     - 多客户端
     - 单客户端异步并发
   - 异步面临的挑战
     - 不同时间的请求/应答如何匹配

**交叠提供的设计机会**

**交错技术**
- 流水线和并行的综合运用

![alt text](image-1.png)

#### 排队问题
**排队的原因：**请求超过服务容量

**排队的系统状态：**吞吐率最低的模块过载运行（常伴随其他模块空转）

**排队时延的特点：**

- 与请求数量有关
- 随时间变化

**时延分析:最简单的M/M/1排队模型**

![image-20250620195422669](/Users/claerlocus/Library/Application Support/typora-user-images/image-20250620195422669.png)

![alt text](image-2.png)

![alt text](image-3.png)

### 调度问题
**排队时，不同请求的顺序问题。**

**调度的本质**
- 计算机系统是请求使用资源的实体的集合
  - 实体:线程、虚存地址、用户、客户端
  - 资源:CPU周期、物理内存、硬盘空间、网络容量
- 调度是派发策略和派发机制的集合，将资源分配给实体
  - 基于性能目标和最低保障进行排序，并实施
  - 实现:调度器

**调度器设计的三个难题**
1. 高层目标与底层调度的鸿沟

高层的调度策略难以被低层模块了解

例：web 服务

2. 策略与派发机制的鸿沟

正确的策略难以派发到所有模块，导致低效率的情况

例：操作系统内核

3. 派发机制与实现的鸿沟

如果派发机制与实现不匹配，会出现活锁

例：recieve livelock

**困难与实际**

**困难**
- 解决调度问题，需要设计复杂的策略
  - 如：航线调度

**实际**
- 大多数计算机系统中，资源不昂贵，可采用简单方案

**调度器的设计挑战**

**调度器主要功能：调度、派发**
- 调度策略：谁先谁后
- 派发机制：执行换入换出

**设计思路**
- 调度策略需要动态变化
- 但派发机制不需要改变
- 如何提高调度器的设计灵活性？
  - 间接层

**设计经验4:将实现从策略中分离**
- 成功案例：在多级存储管理中，缺页处理机制和替换策略是分开实现的

**常用的调度指标**

对于请求：
- 周转时间(Turnaround time):请求抵达到执行完毕的时间
- 响应时间(Response time):请求抵达到开始产生响应的时间
- 等待时间(Waiting time):请求抵达到被开始处理的时间

调度指标：
- 平均周转时间
- 平均响应时间
- 平均等待时间

**常见的调度策略**
1. 先来先服务
2. 最短工作优先——改进：最短工作优先完成
3. 时间片轮转
4. 优先级调度
5. 实时调度

结合多线程之间的数据共享同步、缓存亲和性等，调度策略变得 更加复杂
- 问题复杂性无止境

### 策略优化
#### 性能优化策略
**应对性能瓶颈的优化策略**

1. 批处理

**通过批量完成任务，从而减少平均时延**

系统案例：假如有10个进程申请读写硬盘

2. 等待

**推迟操作，等待该操作过时或创造批处理机会**

系统案例：写硬盘
- 在可以访问的时候推迟访问，等待批处理机会

系统案例：临时文件
- 最后的批处理写入

3. 推测

**在有依赖时，利用空闲资源，提前推测执行，降低时延**

系统案例：CPU 流水线

其他系统案例：
- 文件编辑器：预取文件块
- CPU 缓存：预取数据和指令

**推测面临的挑战**
1. 如何提升预测的命中率
   - 分支预测
   - 值预测？
2. 如果预测失败，如何回退

#### 设计引入的新挑战
**批处理、等待、推测有代价吗?**
  - 引入脆弱性，增加复杂性

“只要资源的利用率不是100%，那么队列的长度就存在上限”这一陈述是错误的，因为即使在利用率低于100%的情况下，队列长度在理论上可以无限增长（尽管概率越来越小），因此不存在一个固定的有限上限。正确的说法是：当利用率低于100%时，系统的平均队列长度是有限的，或系统是稳定的，但队列长度本身是无界的。

## 性能优化案例 硬盘 I/O 瓶颈优化
**吞吐率问题**

吞吐率上限实际远小于理论

**I/O瓶颈**

吞吐率与一次访问的数据量有关

**如何优化**

**三种结构优化方法**
1. 基于工作负载？
- 无重复访问，缓存技术无效

2. 并行？
- 考虑单个硬盘，没有并行的机会

3. 交叠？
- 计算和I/O是不同部件，**有一定可能**

**三种策略优化（先考虑）**
1. 推测？
2. 批处理——批处理的机会通过等待来创造
3. 推测：再贪心一点
   - 如果预取下一个 track
   - 读写被计算时间完全覆盖
   - 计算成为瓶颈
   **以上优化依赖于：文件顺序存储，计算是顺序访问文件的**

**其他优化**
- RAID：多盘并行，读写交叠
- 新技术：闪存

不及时存盘，系统崩溃
- 可靠性：数据丢失
- 原子性：不可分割的任务完成一半
- 一致性：数据处于错误状态

**应对过载**

过载不可避免
- 短时间过载：排队
- 长时间过载
  - 提高服务容量
  - 降低负载

**降低负载**
- 有限缓冲区方法:缓冲区满 → 等待，将瓶颈倒推给开始 → 停止接收请求
  - 如果请求着等待（交互）输出，进入自管理
  - 停止还是推迟？
- 配额方法：如设置活动进程、打开文件等的上限
- 换出一些不能胜任的负载