# 容错与可靠性
1. 可靠性
- 系统在规定的条件下和规定的时间内，完成规定功能的能力
2. 容错
- **用不可靠组件，构造出可靠系统的方法**
- 是获得可靠性的**主要方法**，也是系统设计的**基本需求**

**用不可靠部件构造可靠系统的三个阶段**
1. 检错：
  - 发现数据或信号的错误
  - 思路：冗余
2. 错误遏制：
  - 限制错误传播
  - 思路：模块化
3. 错误屏蔽：
  - 令系统不受错误影响，行为正常
  - 思路：更多的冗余

## 基本概念与容错设计
### 基本概念
1. 故障
- 可能导致问题的低层缺陷，如：
  - 轮胎上的气泡（可能导致车祸）
  - 软件中的悬空指针，可能造成任意内存破坏
  **计算机系统的故障来自各方面原因！**
  （软件、硬件、设计、实现、操作、环境）

软件故障：
- 整数溢出导致符号改变
- 指针错误导致数组越界

硬件故障：
- 逻辑门失效
- 电源故障

设计故障：
- 内存预计不足，导致内存耗尽
- 调度各模块不匹配，导致活锁

实现故障：
- 内存配备未遵循设计
- 程序断言被注释掉

操作故障：
- 错误使用软件，比如rm -rf /*

环境故障：
- 雷击引发电涌，导致数据错误

2. 错误

**故障会立即或在未来产生不一致的状态：错误**
- 违反了设计规范中的断言或不变量的程序状态或数据值

错误相比缺陷，变得可以进行观察和测量。但在没有断言或不变量的情况下，查找错误也通常没有通用方法。

3. 失效

**如果错误没有被检测和消除，模块可能产生意外行为或结果：失效**

- 在模块接口上未产生预期结果

组件的失效是系统的故障

4. 容错

- 发现故障和组件失效，并采取有效应对
- 应对机制
  - 在组件层面上，进行错误遏制
  - 错误所在的模块是错误遏制的最小单位

在**接口**层面上：
- 屏蔽错误
- 报告错误：快速失败设计（fail-fast != failure）
- 停止运行：失败停止设计（fail-stop）
  - 问题：在异步系统中，如何判断stop
- 无反应：（非正式称谓：crash 或 fail-thud = failure）

### 容错设计过程
错误避免：使用可靠部件搭建系统（不正确）

步骤：

系统开发时：
1. 开发容错模型，使用模块化遏制高风险错误产生的危害
2. 设计实现错误屏蔽机制，将机制更新到容错模型
3. 测量可靠性/容错率
4. 根据测量结果进行迭代，直到达到可接受水平

系统运行中：
1. 观察并分析
2. 改进并迭代

涉及的技术与原则：

故障识别、风险计算、成本/收益计算、错误率/可靠性测量

检错技术、纠错技术

显式原则、迭代设计原则、安全边界原则、不断挖掘原则、彻底简化原则

## 可靠性测量与评价
### 可靠性指标
**测量指标**
- 失效时间：TTF
- 修复时间：TTR

**评价指标**
- **平均失效时间**：$MTTF = \frac{1}{N}\sum_{i = 1}^{N} \mathrm{TTF}_i$
- 平均修复时间：$MTTR = \frac{1}{N}\sum_{i = 1}^{N}\mathrm{TTR}_i$
- 平均故障间时间：$MTBF = MTTR + MTTF$
- **可用性：** $A = \frac{运行时间}{应运行时间} = \frac{\sum_{} TTF}{\sum_{} (TTF + TTR)} = \frac{MTTF}{MTBF}$

**为什么要测量MTTF？**
- 评估组件的可靠性，是否达成系统的设计目标
- 预测组件未来行为（需要有统计模型做支持）

**如何测量MTTF？**
- （仅考虑替换，不考虑维修）
- 测量若干组件的TTF，取其平均值

**如何预测MTTF？**

**统计方法**
- 假设失效是时间无关的
    在较短时间t内，运行n个组件，统计失效个数x，进行计算
    $\frac{n * t}{MTTF} \approx x \implies MTTF \approx \frac{n * t}{x}$
- 但有些组件的失效不是时间无关的：
  - 夭折现象
  - 耗竭现象

**假如组件失效不是时间独立的**

**基于模型的统计方法**

1. 基于经验或测量，获得该组件故障率的概率密度函数模型
2. 假设各组件之间的故障是相互独立的，进行一组组件测试
3. 使用测得的值进行回归分析

**结合工程的统计方法**

- 加速老化
  - 需要建立老化与时间的换算模型

**可用性指标**

可用性指标的极简方法：N-nines可用性

### 可靠性计算

> 定义

1. 可靠性函数：

​	$R(t) = Pr$（从开始到t无失效）

2. 无条件故障率：

​	$f(t) = Pr$（在t到dt间失效）

$F(t) = 1 - R(t)$

$f(t) = F'(t)$

> 平均无故障时间和可靠性计算

- $MTTF = \int_0^\infty t · f(t)dt = \int_0^\infty R(t)dt$：如果$f(t)$准确，与实际测量的 MTTF 相等
- 当失效时间无关时（可能是函数的一部分）
  - $MTTF = 1/E$，E为错误率
  - $R(t) = e^{-(t/MTTF)} = e^{-tE}$
- 当失效时间相关时，无简单方法

> 极简方法：nσ法

- 针对生产线产品的某个参数进行控制
- 假设参数符合正态分布，求其标准差$\sigma$
- $n\sigma$标识均值距离错误值可以达到n个标准差

**该方法适用于生产线，不适用于安装运行的组件**

**6σ方法：**

- 1.5σ:生产线均值最多偏离规格
- 4.5σ:产品偏离生产线均值

## 容错模型开发
### 响应分类
**对于错误可能采取的响应方式**
- 无响应：任由错误发生
- 快速失败：发现错误立即报告
- 失败安全：发现错误采取安全方式停止
- 软失败：发现错误仍可部分正常工作
- 屏蔽错误：发现错误并纠正错误

### 错误分类
![alt text](image-4.png)

未容忍错误可能导致失效

错误分类用于开发容错模型

### 容错模型
**基于错误分类开发容错模型**
- 分析系统，将可能错误的时间分类到可检测和不可检测
  - 此时所有错误标记为未容忍错误
  - 如果不可检测错误发生率不可忽略，更改系统设计
- 对于所有可检测错误，实现检测规程
  - 将所有能检测到该错误的模块标记为fail-fast
- 对于所有可检测错误，尝试设计屏蔽机制
  - 如果可行则将此错误标记为可屏蔽错误
- 对于可屏蔽错误，评估发生率、失效代价、屏蔽代价
  - 根据评估结果决定是否实施屏蔽，如实施则划分其为已容忍错误

**问题**
1. 错误事件列表完备吗？概率估计真实吗？
- 现实世界问题，必然包含主观的、经验的判断
2. 用于检测和屏蔽错误的算法、规程、实现等是完备和正确的吗？
- 抽象问题，一般有客观的答案

**容错模型的迭代**

迭代：
- 前提：首先建立模型
- 时机：当错误发生率、类型超出估计时
- 观察：审查模型，发现可以改进的地方
- 行动：改进设计

用迭代应对技术进步
- NFS：从局域网到互联网，重新修改了容错模型

## 容错技术：冗余
**冗余：从模拟到数字**

**模拟系统的容错**
- 保留安全边界

**数字系统的容错**
- 瞬时错误：重试
  - 时间上的冗余
  - 案例：TCP协议
- 永久错误：另一个相同组件提供正确结果
  - 空间上的冗余
  - 案例：汉明码

### 增量冗余：编码
**用汉明距离检错与纠错**

如两个编码的汉明距离（两个比特串对应位置不同字符的数量）为d，则检错能力为 d-1 位，纠错能力为 (d - 1)/2 位

例：
- 奇偶校验n+1可检1位错。
- 4+3可纠1位错

CRC 校验

**应对丢失**

丢位
- 如果知道位置，奇偶校验可恢复1位，4+3可恢复3位
- 称为纠删码

同理，丢包：
- 如果知道序号，那么奇偶校验包可恢复1个包，4+3可恢复3个包

**收益**
1. 广播场景有用
2. 控制时延有效
3. 超远通信必须
4. 长期存储适用

### 规模冗余：复制
**复制：使用同一组件的多个副本**
- 设计出错时的自动替换机制

### 多模块冗余：表决
**N个相同的组件+表决器**
- N模块冗余
- 称为超级模块
- 表决器设计规则
  - 失败投票：服从多数意见

### 维修：量化计算

## 冗余技术应用：软件与数据(低优先级)
### 多版本软件容错
**安装3个软件副本能表决容错吗？**

### 数据状态分离容错
**观察**
1. 错误是不可避免的
2. 软件状态存储于非易失存储和易失存储，出错时维修是不现实的
3. 运行的程序状态分为两类
- 系统失效时可抛弃的
- 系统失效时需要保持的（完整性相关）

**方法**
- 确保易失存储是可以随时抛弃的，非易失存储是收到保护的

### 存储持久性的衡量
**持久性指标：操作完成后结果保持的时间长度**
1. 不长于线程的生存期
- 工作目录、寄存器、cache
2. 不长于非易失存储介质的使用寿命
- RPC记录nonce，编辑器的临时文档
3. 相当于非易失存储介质的使用寿命
- 文件、数据库
- 持久性存储，TTF不稳定，常实施独立多副本
4. 数倍于非易失存储介质的使用寿命
- 档案管理

### 案例：磁盘容错设计
**低成本、大容量、非易失**

**磁盘有哪些错误？**
1. 高精度、紧公差，随时间出现老化
2. 尘粒等，引起磨损
3. 撞击可引起磁头碰撞，引起较大范围损坏
4. 电子元件老化，导致数据读出不稳定或读不出
5. 磁道臂元件损坏，导致寻道错误
6. 写入中途发生断电，导致写入内容只有部分更新
7. 写入中途操作系统崩溃，导致写入错误的内容

**磁盘容错设计**
1. 原始磁盘存储器
   - 功能：
     1. 寻道
     2. 写入
     3. 读出
2. 快速失败磁盘存储器
   - 磁盘控制器中的硬件和固件，将磁道划分为扇区
   - 按扇区进行检错
3. 谨慎磁盘存储器
   - 在磁盘控制器中，通过**重试**等方式屏蔽错误
4. 持久性存储：RAID 1
   - 一检测的硬错误（永久损坏），能否屏蔽？
     - RAID 1，思路：
       - **多副本**：分别存于不同磁盘
       - **间接层**：使用虚拟扇区号，RAID控制器做映射

**如何检测系统崩溃导致的错误？**
目前还剩下内核崩溃的错误未能容忍，why？
- 数据的损坏发生在数据传输给硬盘之前
- 只能从内核或应用入手解决