# 原子性与隔离
**计算机系统工程的重要目标：**
- 用不可靠的组件构建可靠、高效、正确的系统，即：
- 在高可用性的前提下：
  - 服务更多用户，存储更大数据量，提供更快速度

**可靠性工程**
- 识别错误、检测错误、处理错误、防止失效发生
- 逐步构造通用的抽象模块，逐层构造可靠性

**为了保证一致性，提出了原子性和隔离：**
- 保证存储系统多个连续操作的结果一致性

原子性：All-or-Nothing 属性
- 屏蔽错误

隔离：Before-or-After 属性
- 协调并发活动

## 影子副本方法（shadow copy）
**能够保证两种原子性的抽象，称为：**

- 事务处理（通用概念）

哪两种？（原子性与隔离）

**事务处理的抽象**

- 更好地寻求更多模块组合的可靠性

**原子性与隔离的实例**
|领域|原子性|隔离|
|---|---|---|
|数据库管理|更新1条以上记录|多线程操作同一条记录|
|硬件体系结构|处理中断或异常|寄存器重命名|
|操作系统|系统调用接口|打印队列|
|软件工程|处理下层错误|有界缓冲区的操作|

**流水线导致相邻指令可能并发**

为什么要重命名？交叠

**影子副本的性能问题：**

无论多小的修改，都要复制整个 bankfile，修改文件后，再改名文件

**锁的复杂性问题**

锁需要做全局的分析，了解每一处访问，并设置不同的锁

## 日志方法
目标：原子性

收益：性能

成本：复杂度

日志方法与影子副本不同，只写入改变的值

读操作仍很慢

**用单元存储改进读操作**

**用缓存来改进写操作**

## 两段锁方法（2PL）
**为了实现隔离直接、有效、低效的方法：使用锁（甚至全局锁），使操作实际上串行化**

可串行化不只有一种定义，使用不同的定义取决于应用的需求

更强的正确性要求：
1. 外部时间一致性
   - 银行：外部事件的顺序，必须反映到操作上
2. 顺序一致性
   - CPU：并发执行某指令流时，应与程序按原始顺序执行结果相同

**冲突：**

如果两个操作访问同一个对象，且至少一个操作是写操作，那么这两个操作存在冲突

在调度中，冲突的一对操作的先后顺序(A早于B或B早于A)，称之为该调度中该冲突的序。

**法则：冲突可串行化当且仅当其冲突图中没有环**

**目标：并发运行事务但生成可串行化的调度**

**2PL**

1. 共享变量有自己的锁
2. 任何操作前，事务必须获得该变量的锁
3. 事务释放锁之后，不能获得其他锁

一般在 commit 之后释放锁，这是技术上严格的 2PL

2PL 生成的调度是冲突可串行化的

2PL 生成的调度不能避免死锁的产生，解决：

全局锁排序是一种（低效）选择

利用原子性方法，撤销死锁操作

### 性能优化
**带读写锁的 2PL**
1. 共享变量有自己的2个锁:读锁和写锁
2. 任何读/写操作前，事务必须获得该变量的读/写锁
3. 变量的读锁可以同时被多个事务获得，变量的写锁只能同时被1个事务获得;
4. 事务释放锁之后，不能获得其他锁。

继续优化：读锁在 commit 之前释放

- 冲突可串行化是相对严格的一种调度方式。
- 2PL可以产生冲突可串行化的调度，通过将读锁和写锁区分，可以提升其性能。
- 2PL → 冲突可串行化，但2PL不产生所有的冲突可串行化调度

## 总结
- 原子性: 使用日志得到了更好的方案
- 隔离: 使用2PL进行保证