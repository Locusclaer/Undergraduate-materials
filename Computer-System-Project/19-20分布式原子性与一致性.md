# 分布式系统的原子性与一致性
**日志和锁需要本地共享资源，不适用于分布式系统**

- 分布式原子性：2PC

**但是无法应对服务器永久故障，需采用副本服务器进行容错**

- 分布式一致性：

## 分布式原子性

### 问题提出

**如何应对各类故障？保证多主机事务原子性**

故障：消息丢失、乱序；协调器、服务器故障

### 分布式系统

- 为什么存在/需要分布式系统？
  - 可靠、安全
  - 性能
  - 数据的地理分布特征

### 2PC 算法（二阶段提交）

**特点：**

  提交前，各个主机做好准备并达成一致

#### 故障处理

- 故障1:消息丢失
  - 通过可靠的数据传输协议解决
- 故障2:准备阶段前，服务器故障
  - 协调器可以安全地中止事务，无需通知各个服务器
  - 协调器通过简单的握手协议（心跳协议）就可以检测
- 故障3:准备阶段中，服务器或协调器故障
  - 协调器可以安全地中止事务，**并通知**各个服务器**中止**
- 故障4:提交阶段中，服务器或协调器故障
  - 协调器不能中止事务！
  - **所有参与者**必须在恢复时提交

**规则：提交点之后，不能再中止事务**

如果协调器永久失效，该方案无法解决！

**新问题：在当前协议中，若果某台服务器失效，那么该服务器存储的数据永久不可用**

- 方案：复制数据，多个副本。
- 但是要考虑这些副本如何保持一致性？他们保持何种程度（类型）的一致性？
- 新的问题：分布式一致性 = 分布式写读连贯性

### 总结

- 能够保证两种原子性的抽象：事务处理
  - 在事务处理的抽象之上，更好地实施可靠性
- 方案
  - 原子性：
    - 使用日志得到了更好的方案
    - 使用2PC保证多主机（分布式）的原子性
    - 提交点是重要概念，副本将带来一致性的问题
  - 隔离：
    - 使用2PL进行保证

## CAP 定理与分布式系统概述

> 分布式系统希望达成三种属性：

- 一致性C：所有节点都能读到更新后的数据
- 可用性A：所有请求都能实时得到应答
- 分区容错性P：当系统出现消息丢失或网络分区故障时，仍然可以提供服务

### CAP 定理

一致性、可用性、分区容错不可兼得

**P 显然是现实的要求**

- 网络连通性通常是没有保障的

**AP：牺牲C**

**CP：牺牲A**

> CAP 不是二元决策

**系统可能在可用性和一致性间折中，部分的 A 和部分的 C**

### 分布式系统概述

#### 相关概念

1. 分布式系统

- 一组可以通信和消息交换的计算机

2. 分布式计算

- 研究分布式系统及其使用的学科

3. 分布式算法

- 用于解决分布式系统**基本问题**的算法

4. 分布式应用（及应用算法）

- 在分布式系统上解决**应用问题**

#### 分布式 vs 并行 vs 高性能计算

**并行计算 != 分布式计算**

- 全局时钟与独立故障

**高性能计算 约等于 并行计算**

- 将并行等技术应用于计算场景

#### 分布式系统特点

1. 并发
2. 缺乏全局时钟
3. 故障独立

- ……
- 差异：距离、时延、通信链路质量、算力等都可能存在巨大差异

### 典型算法举例

> 快照算法

- 目标：获取当前各节点状态
- 用途：全局性质的计算依据
  - 备份恢复、出现死锁、存在垃圾等
- 挑战：
  - 在运行中获取，而非暂停
  - 没有全局时钟
- 算法功能：
  - 获得“一致”的快照

**Chandy-Lamport 算法**

> 广播算法

- 目标：将消息发送给网络中所有节点
- 用途：收集信息
  - 终止检测、路由、选举
- 算法功能：
  - 遍历所有节点，每个节点至少一次

**Tarry’s 遍历算法**

> 死锁检测

**死锁的概念**

- 节点因为**阻塞性等待**其他节点或其所占有的资源长期形成的长久回路
- 通信死锁与资源死锁

**分布式系统的死锁消除**

1. 获得全局快照
2. 进行死锁检测
3. 调度进程回滚

**Bracha-Toueg 死锁检测算法**

## 分布式一致性

**分布式一致性：**

- 多个存储单元副本，在更新后能读到相同的结果

**写读连贯性：**

- 单一存储单元，可能包含高速缓存（cache），在更新后能读到相同的结果

> 分布式一致性与共识

**一致性：**

- 多个副本对外呈现的数据状态是相同的

**共识：**

- 多个节点之间达成某种一致结果的过程

**关系：**

- 一致性描述的是结果状态，共识则是实现一致性的手段和前提
- 但达成某种共识并不意味着保障了一致性

> 分布式一致性分类

**一致性分为：**

- 强一致性：每次读到的值都是最近一次更新的值（2PC是强一致的，通过协调器阻塞）
- 弱一致性：每次读到的值可能并不是最新的，可能是某个旧值
  - 弱一致性可以换来更高的性能和更好的可扩展性
  - 最终一致性：在排除并发写的情况下，如果存在一个时刻（不是立刻）可以让系统达到强一致的状态，这种弱一致性叫做最终一致性

> 强一致性

**从分布式系统的逻辑时钟来看，由强到弱：**

- 线性一致性
  - 读操作可以访问到最近的写操作，最近的意义根据全局时钟。
- 顺序一致性：
  - 全局的读写顺序与每个节点程序的执行顺序一致
- 因果一致性：
  - 只有事件的因果关系（或偏序）被保持

### 2PC 和 3PC 共识机制

#### 2PC 共识机制（强一致性）

**问题：**

1. 阻塞-性能低：无超时机制。
2. 需100%通过，条件苛刻，容错性差
3. 协调器是单点故障

**共识机制不保证终止：**但如果终止则一定是正确的结果

#### 3PC 共识机制（最终一致性）

1. 解决阻塞问题
2. 假如准备到提交阶段有服务器崩溃，仍可以进行

问题：不确保正确

> FLP 不可能定理

在网络可靠，存在节点失效(即便只有一个)的最小化异步模型系统中，不存在可以解决一致性问题的确定性算法。

### Paxos 分布式共识机制

**设计目标：**

- 对分布式系统的某个值或行动达成一致

**需要考虑的系统属性：**

- 正确性
- 分区容错性
- 中止性

#### Paxos 协议分析

**为什么设置多个投票者？**

- 防范单个投票者的失效导致的故障

**为什么不直接接受第一个提案？**

- 多个领导者可能导致没有多数接受的结果
- 领导者故障

**如果有多个活动的领导者怎么办？**

**V 在什么时候能够选定？**

- 领导者收到多数的承诺
- 多数投票者收到请求接受的消息
- 领导者/学习者收到过书的接受消息

**Paxos 可保证一组节点达成对一系列事件的一致性结果**

**Paxos 可容忍各类的故障，但不能容忍恶意攻击**

### 区块链共识机制

**区块链主要形式是公有链**

**PoW 共识**

- 应用：比特币

**PoW 思路**

- 以投入作为担保，使用资源（获得回报）
  - 如果有违规行为，则投入会被扣除，且资源无法使用

#### HashCash

**最早设计用于对抗垃圾邮件**

#### PoW分析：主要问题

1. 资源浪费
2. 性能低
3. 算力集中化的两难问题

#### 其他的区块链共识机制

1. 股权证明（PoS）
2. 授权股权证明（DPoS）
3. 实用拜占庭容错（PBFT）
