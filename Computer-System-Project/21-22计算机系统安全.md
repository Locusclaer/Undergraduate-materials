# 计算机系统安全

**计算机系统工程的重要目标：**

- 用不可靠的组件构建可靠、高效的系统
- 在高可用性的前提下：
  - 服务更多用户、存储更大数据量、提供更快速度

**可靠性工程**

- 识别、检测、处理错误，防止失效发生
- 逐步构造通用的抽象模块，逐层构造可靠性

**计算机系统安全**

- 内涵：保护计算机系统、系统数据、用户身份的安全
- 界限：不涉及“计算机应用于其他领域安全”

## 数据安全与安全协议

### 隔离与防范机制

**安全基本方法：隔离**

> 隔离数据的几种机制设计

1. 密码算法封装

- 秘密：封锁与开启数据的钥匙
  - 用户：掌握秘密
  - 非用户：不掌握秘密

2. 认证与访问控制

- 权限：允许访问的凭证

### 基本的密码算法

> 前科学时代：基本方法

**古典加密两种基本思路：**

1. 替换
2. 换位

**攻击方式：**

1. 概率
2. 模式
3. 暴力

> 前科学时代：vernam 方案

**最安全的加密方式**

- Vernam 方案
  - $P \oplus K = C$：具有完善保密性
- 完善保密性（无论是否知道密文，推出明文的概率相等）
- 缺点分析：根据概率公式可以计算出，密文与明文完全无关，但是密文又是明文与密钥算出来的，这就要求每次读密钥需要完全随机且不同，这点难以保证。并且要求`密钥长度>=密文长度>=明文长度`加密少量的数据可能需要大量的空间，效率低下。

> 现代密码学：对称加密算法

1. 分组加密

- 将消息分成多个分组
- 算法建立了**消息**分组到**密文**分组之间的替换表（密钥）

2. 序列加密

- 能用密钥**持续产生比特流**的算法，用比特流与消息做异或

> 分组加密

**初始设置**

- 寻找复杂的加密函数：$f(P, K) \to C$，且存在可计算的逆函数$f^{-1}$
- 产生密钥k，并分发到通信双方

**加密过程**

1. 将明文分为等长分组$<p_1,p_2,...,p_n>$

- 分组可看作整数

2. 将每个分组p用函数f和K转换成密文c：

- $f(<p_1,p_2,...,p_n>,K) \to <c_1,c_2,...,c_n>$

**解密过程**

- 使用$f^{-1}$和$K$，将$<c_1,c_2,...,c_n>$转换成$<p_1,p_2,...,p_n>$

**弱点：**

- 存在可被利用的条件概率
- 如何消除这一问题？

==**方案：工作模式**==

- 方案一：分组先与上一组的密文异或，再加密（密码分组链接CBC）
  - 收益：同样分组，不同密文
  - 缺点：不能并行
- 方案二：先加密上一组的密文，再与分组异或（密码反馈CFB）
- 方案三：反复加密某个IV，与分组异或（输出反馈OFB）**能持续产生密钥流**

> 序列加密

**初始设置**

- 算法
- 初始向量IV + 密钥key

**加密过程**

- 使用算法产生持续的密钥比特流
- 将密钥与消息流异或产生密文流

**解密过程**

- 解密过程与加密过程相同

**特点**

- 基于数学方法的安全分析较成熟，使其广泛用于军事、外交等关键领域

> 对称加密算法的问题

1. 加密密钥必须保密
2. 不能用于证实身份
3. 密钥分发开销大

> RSA 公钥加密算法

**选择2个大素数：p 和 q**

**计算密钥：**

- n = pq
- $\varphi(n) = lcm(\varphi(p),\varphi(q)) = lcm(p - 1, q - 1)$
- 选择整数e，使$1 < e < \varphi(n)$且$gcd(e,\varphi(n)) = 1$（即二者互素）
- 求解整数d，使$ed ≡ 1 (mod\space\varphi(n))$ （即d 为 e 模 $\varphi(n)$ 的逆元）

**分发密钥：**

- 将(n, e)公开发布，(n, d)秘密发布

**加密/解密：**

- $(m^e)^d ≡ m(mod \space n)$

### 用密码学保护数据

### 基本使用方式

> 消息加密（公钥加密，私钥解密）

保护机密性

> 消息鉴别（私钥加密，公钥解密）

保护完整性

### 将加密算法用于协议

#### 用安全协议保护数据传输

**数据传输的安全需求**

1. 数据机密性
2. 数据完整性
3. 身份鉴别

**安全传输协议SSL/TLS**

> 握手协议

用于：

- 进行相互认证
- 协商算法参数
- 启动其他协议

**四阶段消息交换**

- 阶段1:建立安全能力
- 阶段2:认证与密钥交换
  - 服务器：发送证书、进行密钥交换、请求证书
- 阶段3:客户端认证与密钥交换
  - 客户端：发送证书（如需要）、进行密钥交换
- 阶段4:执行修改密码规范协议
  - 双方：切换协议

**结果：**生成双向MAC、IV、密钥 共六个

**握手协议的安全性**

- 基本使用明文
- 安全机制：
  - finished包中PRF函数可以发现内容篡改

> 修改密码规范协议

- 使用记录协议通信
- 仅包含1字节：payload = 1
- 将刮起状态改编为当前状态（原子操作）
- 更新密码算法组

> TLS 会话与 TCP 连接

**TLS 会话**

1. 使用握手协议建立TLS会话
2. 建立在TCP连接之上
3. 可以重用于多次连接
4. 客户端-服务器之间的单向关联 
5. 规定了密码相关的参数

> 记录协议

**保护数据完整性**

**保护数据机密性**

应用数据 -> 消息分段 -> 压缩 -> 增加MAC -> 加密 -> 加入SSL头

#### 安全性问题

> 身份的安全

**鉴别服务器身份**

- amazon.com Inc发布公钥并签署其所有网站，以此类推

**鉴别用户**

- 证书
- IP地址或口令

**信任是安全的基石**

> **算法与协议的安全**

**服务器/浏览器的安全设置**

> 警告协议

**发送安全警告信息**

- 字节1
  - 1表示普通警告
  - 2表示致命警告（立即停止）
- 字节2
  - 警告代码

> 心跳协议

**定期发送，表明协议实体的可用性**

**功能：**

- 确认存活性

- 在连接空闲时产生消息活动

**心脏滴血攻击**

## 隔离、身份与访问控制

### 系统内数据保护框架

**系统数据保护的基本问题：**

1. 加密
2. **隔离、认证和访问控制**

### 隔离

**主机**形成隔离的执行环境

> 主机的形态与隔离方式

**形态**

1. 物理机
2. 虚拟机
3. 进程
4. 代码块

计算机环境硬件安全隔离enclave

> 隔离下的共享

1. 物理机之间，用物理链路通信和共享
2. 虚拟机之间，用虚拟链路通信和共享
3. 进程之间，用IPC进行通信和共享
4. 代码块之间，用语言运行库/解释器共享

> 控制共享的通用模式

身份认证 -> 控制授权

**认证：证明主体的身份**

- 证明某主体就是其声称身份的过程
- 访问监控器可以监控访问者的身份

**授权：按策略控制信息流动**

- 对实体间的信息流动予以安全相关控制的过程

**审计：发现和追溯问题**

- 对操作记录进行安全相关审查的过程

### 身份认证

**证明某主体就是其声称身份的过程**

> 认证技术的分类和要求

**数字世界的身份认证**

- 环境特点：穿越不安全的区域
- 风险：可能被窃听和重放
  - 重放：重复或延迟使用有效的数据，起到欺骗的目的
- 应对思路：每次使用的认证信息都不同

**网络认证的基本要求**

- 认证消息
  1. 不可伪造性
  2. 新鲜性
- 认证系统
  1. 数据传输完整性与认证相结合
  2. 完全介入

> 基于证书的认证

**互联网的认证需求的复杂性**

1. 命名问题
2. 信任问题

**解决命名问题**

- 方案：用**公钥**命名各类主体（标识）
  - 不易碰撞，具有唯一性
  - 可携带，可穿越管理域
  - 可签名、认证，可传递、分发
- 问题：信任
  - 如何将**公钥**关联到**可辨识名称**？**证书**
  - 如何确认**名称**和**物理实体**关系？**注册**

**证书的信任体系**

- 问题：如何将公钥关联到名称？如何建立广泛的信任？
  1. 基于**物理会面**的P2P公钥分发
     - 特点：成本低、扩展性差、效力弱
  2. 基于**权威机构**的公钥分发
     - 特点：有成本、扩展性好、效力强

**基于PKI的信任链**

- 对证书的信任来自于信任链

**注册：确认名称和物理实体关系**

- 策略
  - 先来先服务
  - 安全引导
  - 行政体系

> 基于口令的认证

==**口令是最常见的 Know Sth 认证方式，以下为基于口令的认证方案：**==

1. C -> Server：我是A，我的口令是P

- Server：查询 Name=A 且 Password=P 的记录，如果有就成功

2. C -> Server：我是A，我的口令的hash值是H

- Server：查询 Name=A 且 Hash(Password)=H 的记录，如果有就成功

3. C -> Server：我是A，我的口令的hash值是H

- Server：
  - 在数据库中仅保存用户名和口令的Hash值
  - 查询 Name=A 且 Hash=H 的记录，如果有则成功

4. Server：我是A，我的 **口令+Salt** 的hash值是H

- Server：
  - 在数据库中仅保存用户名和 **口令+Salt** 的Hash值
  - 查询 Name=A 且 Hash=H 的记录，如果有就成功

**口令安全问题**

- 如何防止口令被窃取和暴力猜测？
  - 应对窃取 -> Hash
  - 应对猜测 -> 限制尝试次数
- 什么样的口令容易被猜测？**弱口令**

**口令安全性方案：**

1. 口令管理器

- 功能
  - 自动生成、自动填充
  - 高熵口令、多个口令
- 安全性
  - 本地运行，攻击面少
- 易用性
  - 用户只需记住一个口令
- 口令管理器是单点故障

2. 双因子

- SMS、扫描二维码等
  - 安全分析：依赖电话号码真实、基站安全、终端安全、终端在线
  - 易受攻击：钓鱼
- U2F by FIDO
  - 模式：基于挑战-应答
  - 设备：适配器 + 公私钥对

### 访问控制

**访问控制：对实体间的信息流动予以安全相关控制的过程**

#### 访问控制模型

> 简单防护模型

函数：permissions = policy

两种实现方式：

- 按列实现：访问控制列表（ACL）
- 按行实现：能力（Capability）

**谁来规定策略**

- 自主访问控制（DAC）
  - 客体所有者
- 强制访问控制（MAC）
  - 管理员
- 基于角色的访问控制（RBAC）
  - 应用程序设计者规定角色的策略
  - 管理员分配用户的角色

> 看守者模型

**简单保护模型的面向对象设计**

- 特点
  - 能够设定任意访问：不仅仅是read、write、execute
  - 能够设定上下文：时间、访问者属性等
  - 能够设定复杂方案：门限访问等

无论简单模型还是看守者模型，进程都可以**在不同客体间传递信息**，从而导致被保护的信息泄露。

> 信息流控制模型

动态分析数据在进程中的流动

- 将进程的内存和通信也纳入到控制中

**信息流控制的策略**

- 主客体分级分类，级+类组成复合的密级：
  - 分级（全序）
  - 分类（偏序）
- 信息流控制策略

