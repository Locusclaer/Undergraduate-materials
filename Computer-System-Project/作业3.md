# 线程与虚拟解释器
## 1. 简述如何通过编程证明两个线程共享内存？
可以创建一个共享变量与两个线程，让这两个线程都能够访问并修改这个共享变量。若两个线程共享变量，那么如果一个线程对变量进行了修改会立刻影响到另一个线程中看到的这个变量的值。比如编写一个函数，在函数中对该共享变量进行10次的循环自加，创建两个线程同时执行，最终得到的结果应该是这个变量的值增加了20（如果没有加锁可能会产生数据竞争导致最终增量小于20）。
## 2. 简述如何通过编程证明线程具有独立堆栈，以及确定堆栈的大小？
### 证明线程具有独立堆栈
可以在主函数中声明一个局部变量，打印出它的地址，另外创建两个线程。在线程函数中声明一个局部变量，将主函数中创建的两个线程的参数传入，打印出这两个线程中这个局部变量的地址，观察对比这三个地址是否相同。
### 确定栈的大小
在 C语言的 pthread.h 头文件中有`pthread_attr_getstacksize()`函数可以获取堆栈的地址和大小，不过需要先使用`pthread_attr_init()`初始化默认线程后才能使用。还可以使用`pthread_create`创建线程后通过同样的函数来获取。
## 3.
交换前可能由于线程1发现缓冲区满，然后释放锁开始等待锁，但是在等待时线程2获得了锁，导致缓冲区不再满，并且发出`not_full`的通知，但是由于线程1在等待中，无法接受到这个通知，导致通知丢失。
### （1）对/错：交换会导致新的条件竞争
错。交换后当前线程会在持有锁的情况下进入等待，这样就避免了通知丢失的问题。
### （2）对/错：交换会导致死锁
对。线程会在持有锁的情况下等待，此时其他线程无法再获得锁并改变条件来发出通知，会导致所有线程都持有锁并且进入等待，形成死锁。
## 4. 当两个线程并发支付100，简述balance会产生什么结果并说明原因。
1. 正确的结果
第一个线程检测到`balance`为100，成功扣款后将之归零后返回 success，第二个线程检测到`balance`为0后返回 fail。
2. 竞态条件下数据竞争导致结果错误
两个线程同时都检测到`balance`为100，都执行扣款操作，导致`balance`最终变为-100。
产生错误的原因是没有使用锁来保护`balance`，导致多个线程可以同时访问并修改它，另外`balance >= amt`和`balance -= amt`都是非原子性的操作，多个线程可以交互执行，产生竞态条件。
## 5.
### 1）程序中每一行开头的的这些数字代表什么？
A

每行开头的数字对应处理器发出的虚拟地址
### 2）栈上的值5是什么意思？
A

栈指针指向的应该是 PRINT_MSG 执行后的返回地址
### 3）处理器正在执行哪个过程？
B

位于栈顶的19是将被 PRINT_MSG 输出的值
### 4）PRINT_MSG将一个值写入quote，并将其存储在 71FFF2hex 地址，并期望该值最终会出现在终端上。使用什么技术来实现这一功能？
A

通过硬件的寄存器映射到内存地址中
### 5）线程 0 正在运行（即current_thread = 0）。下一次线程 0 在 YIELD中执行返回指令后，处理器将运行哪条指令？
C

线程0的SP指向36，返回后应该从 PRINT_MSG 的调用点继续执行35
### 6）每个线程的堆栈上可以有哪些地址值？
B

simplePC堆栈上唯一的值就是返回地址
### 7）为确保线程包的正确运行，应在地址 42 处的 while 中求值什么表达式？
B

需要当前线程的状态被设置为可执行，调度器才能调度执行下一个线程
### 8）假设线程 0 正在运行，而线程 1 没有运行（即调用了 YIELD）。为了使线程 1 能够运行，需要发生什么事件
B

为了能够运行线程1，需要将它的状态设置为 RUNABLE，因此需要线程1的中断程序调用 NOTIFY
### 9）每个线程的堆栈上可以有哪些值？
B

中断程序会将当前运行线程的 pc 保存在当前运行线程的堆栈中，因此栈上可能会有任何指令的地址，包括设备驱动程序中断程序中的指令地址
### 10）什么情况下线程0会死锁？
A

A：线程0即将调用 YIELD 但是还没有将线程0的状态设置为 WATTING，设备中断线程0，调用 NOTIFY 将线程0的状态设置为 RUNABLE，之后才执行 YIELD 将线程0的状态设置为 WATTING。调度器发现线程0的状态是 WATTING，切换到别的线程将线程0跳过，形成了死锁。

B：调度器能够正常检测到状态为 RUNABLE 的线程0，不会死锁。

C：此时`input_available[0] <- FALSE`尚未被执行，`input_available[0]`仍然是 TRUE，所以中断程序 do nothing，直至变为 FALSE，不会产生死锁。

D：此时线程0已经是 WATTING，因此中断发生后正常按照逻辑执行，不会发生死锁。