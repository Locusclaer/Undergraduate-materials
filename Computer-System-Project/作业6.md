# 原子性与隔离
|姓名|学号|
|----|----|
|翟一航|23020011046|
### 问题1:对于以下每个锁的相关规则，这个规则对始终保证任何一组并发事务之间正确的隔离，是必要的、充分的，还是既不必要也不充分？
- A. 在事务开始后且在第一个读取或写入KeyDB[k]之前必须获取锁Lk，在最后一个读取或写入KeyDB[k]之后但在事务结束之前必须释放锁Lk。
- B. 每个所需锁的获取操作必须在事务开始后且在任何其他操作之前发生，如果线程修改了相应的数据项，则在事务完成或中止之前不能释放锁。
- C. 每个所需锁的获取操作必须在事务开始后且在第一个释放操作之前发生，如果线程修改了相应的数据项，则在事务完成或中止之前不能释放锁。
- D. 所有获取多个锁的线程必须按照相同的顺序获取锁，不能在事务完成或中止之前之前释放锁。

每个所需锁的获取操作必须在事务开始后且在第一个释放操作之前发生，在事务完成或中止之前可以在最后一个读取或写入相应数据之后的任何时间释放锁。

#### A
不充分也不必要

充分性：交替进行锁的获取和释放，如果一个线程先进行数据的写入操作，那么在另一个线程之后进行数据的读取就会读取到脏数据，因此不充分。

必要性：2PL不是保证可串行化的必要条件，有其他的条件也可以保证可串行化，比如说按照时间戳排序等，因此不具有必要性。

#### B
充分但不必要

充分性：事务开始后进行所有锁的获取，进行写入操作的锁会在事务完成或中止之后释放，进行读操作的锁可能会在最后一次访问数据后被释放，不会影响并发事务之间的隔离性，有充分性。

必要性：使用严格2PL可以更好地保证隔离性，也不具备必要性。

#### C
充分但不必要

充分性：同B，能保证正确的隔离性，具有充分性。

必要性：同B，也可以使用严格2PL来保证隔离性，故不必要。

#### D
充分但是不必要

充分性：按照相同的顺序获取锁，可以预防死锁，并且锁持有到事物结束，这是严格的2PL定义，可以保证可串行化，是充分的。

必要性：按照顺序获取锁，并且持有锁到事务结束并不是唯一的解决可串行化问题的方法，使用基本的2PL方法也可以，不是必要的。

### 问题2：确定以下每个锁的相关规则是否可以避免或可能（随着时间无限接近1的可能性）消除任何一组并发事务之间的永久死锁。
- A. 每个所需锁的获取操作必须在事务开始后且在任何其他操作之前发生，且在事务完成或中止之前不能释放锁。
- B. 每个所需锁的获取操作必须在事务开始后且在第一个释放操作之前发生，且在事务完成或中止之前不能释放锁。
- C. 所有获取多个锁的线程必须按相同的顺序获取锁。
- D. 当事务开始时，设置一个定时器，其时间长于预计的事务执行时间。如果定时器超时，则中止当前事务，并通过随机指数退避算法选择一个新的时间值，然后再次尝试执行事务。

#### A
事务在开始后立刻获取所需要的所有事务锁，之后不再获取新锁，直到事务完成或中止后释放锁。这是严格的二阶段锁，不存在有的事务持有一部分锁并等待其他的锁。可以避免死锁，但是不能消除永久死锁，因为死锁根本不会产生。

#### B
也是严格的二阶段锁，类似于 A 在第一个释放操作之前获取所有的锁，没有事务会部分持有并等待其他锁。可以避免死锁，但是不能消除永久死锁，因为死锁不会产生。

#### C
锁的获取按照顺序，锁的释放没有限制。这种情况下，不可能会出现循环等待。因而可以避免死锁，但是不能消除永久死锁，因为死锁不会产生。

#### D
可能会发生死锁，因为没有打破死锁发生的四个必要条件，但是可以消除永久死锁，由于存在定时器，如果由于死锁导致事务超时，会将事务中止，所有的锁被强行回收，之后根据随机指数退避算法重新选择时间值，并重新获得锁，不太可能会陷入相同的死锁状态。