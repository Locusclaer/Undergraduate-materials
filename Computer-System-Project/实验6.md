# PostgreSQL 数据库与事务
|姓名|学号|成绩评定|
|----|----|----|
|翟一航|23020011046||

## 1. 实验目的
1. 理解数据库的概念、结构和组成部分，以及数据库管理系统（DBMS）的作用和功能。
2. 理解数据库事务的概念和特性 ， 了解事务的概念、ACID属性、事务的隔离级别等重要内容，以及事务处理的原子性、一致性、隔离性和持久性的保护机制。
3. 学习事务管理和并发控制，处理并发操作时的锁定机制、事务回滚和提交等操作，以及解决并发冲突和死锁等问题。
4. 通过实际操作掌握数据库技术的应用和实践能力，提高数据库管理和开发的实际操作技能。

## 2. 实验过程与习题
### 2.1 PostgreSQL 数据库安装及建标
在终端中一次输入命令`sudo apt-get update`、`sudo apt-get install postgresql postgresql-client`，安装 PostgreSQL 数据库（如图一所示）。安装完毕后，系统会创建一个数据库超级用户 postgres，密码为空。之后输入命令`sudo -i -u postgres`进行用户切换，即可进入数据库，之后输入命令`psql`启动数据库。接下来创建实验用数据表，根据安装指南输入命令，创建表后插入数据（如图二所示）。

### 2.2 数据库并发测试
在第一个终端中输入`begin;`开始一个事务，首先输入`select * from accounts;`打印出数据库中目前的所有账户信息（如图三所示）。接着，在第二个终端中也开启一个事务，输入命令`insert into accounts values('chuck', 'Charles Robinson', 55);`插入一个新的账户。

#### 2.2.1 使用两个终端获取所有账户列表。你认为会是什么样的输出？它们相同吗？为什么？
在两个终端中分别打印账户信息（第一个终端的打印结果如图四，第二个终端的打印结果如图五）。
可以发现，第一个终端的打印结果与之前相同，但是第二个终端的打印结果添加了一行最新的数据，它们的输出并不相同。这是因为我们启用了两个事务，进行了多线程的数据修改，第二个线程的数据添加还没有进行提交，属于临时修改，数据库还没有进行更新，所以无法影响数据库。

#### 2.2.2 接下来在第二个终端中提交事务（输入commit;命令），然后在第一个终端中查询账户列表，观察结果，思考为什么新添加的Chuck账户不在结果中？
第二个终端，如图六所示。

第一个终端，如图七所示。

这与 PostgreSQL 的事务隔离级别有关。PostgreSQL的默认隔离级别是 *READ COMMITTED*，在该隔离级别下，一个事务只能看到其他事务已经提交的修改，第一个终端的 begin 早于第二个终端中新事务中新数据的插入，所以第一个终端的事务只能够使用它开始之前的数据库中被提交的数据，后续其他事务的数据提交无法影响第一个终端中事务的视图。

#### 2.2.3 在第一个终端中提交事务，并再次获取所有的账户列表。你认为会是什么样的输出？它与问题2的输出相同吗？为什么？
如图八所示

第一个终端中提交事务，再次获取所有的账户列表，应该能够获取到数据库中的最新内容，即应该包含第二个终端中的事务提交的内容。它与问题2的输出不相同，这是因为问题2中，事务1没有提交，使用的还是该事务开始前数据库中的旧有数据，但是问题3中将事务1进行了提交，再开始新的事务获取数据库中数据时，此时使用的是更新后的新数据。

### 2.3 事务特性
现在在两个终端中开启两个不同的事务，来修改同一个账户的信息，首先在第一个终端中先开启事务，将5美元存入 Mike 账户（如图九所示），再在第二个终端中开启事务，从 Mike 账户中取出 10 美元（如图十所示）。

#### 2.3.1 你认为第二次执行后会发生什么，为什么？
在第二个终端中操作会卡住无法进行，即无法输出`UPDATE`的成功提示。这是因为第一个终端中的事务已经在对账户进行修改操作，并且没有提交，此时事务1修改账户信息的操作获得了锁，来保证操作的原子性。事务2再想对账户进行修改操作时，由于一直在等待事务锁的获取，但是事务1由于没有提交不会释放锁，这时候就产生了问题，事务2只能等待事务1先对账户进行修改，直到它释放锁之后才能够进行，如此一来就避免了事务之间争相修改账户信息带来的数据竞争。

#### 2.3.2 我们在第一个终端中执行abort;取消存入5美元的操作。你认为会发生什么？第二个终端的事务会发生什么情况？如果我们在第二个终端进行commit操作会发生什么？你认为Mike的账户会发生什么变化？
结果如图十一所示。

第二个终端的事务会成功修改账户数据，并显示成功信息`UPDATE`。commit 操作之后修改被正式提交给数据库，彻底修改数据库中 Mike 账户的金额，导致最终账户金额变化应该是 Mike 的余额 -10（结果如图十二所示），观察发现确实如此。

**现在假设我们在同一个事务中使用两个UPDATE语句执行从Ben到Alyssa的15美元的转移（如图十三所示）。在此之前检查数据表内容（图十二）。**

#### 2.3.3 哪条命令之后，第二个终端执行的结果会在第一个终端展现出来？
`commit;`命令之后。理由同上，只有在 commit 之后数据修改才被保存提交到数据库，其他事务得到最新的数据才能够显示出来（结果见图十四）。

## 3. 遇到的问题及解决方式
**下载 PostgreSQl 数据库时出现无法下载的问题**
开始时，根据实验要求来一步步进行，但是却出现如图十五所示的报错。

发现是系统存在依赖关系冲突，特别是MySQL和PostgreSQL的依赖包版本不一致。之后在终端中输入命令`sudo apt --fix-broken install`，希望尝试自动修复依赖关系，但是又出现了如图十六所示的报错。错误显示在尝试修复依赖关系时遇到了 网络连接问题（无法解析 cn.archive.ubuntu.com），导致无法下载 mysql-server-8.0 的更新包。接下来需要解决网络连接问题。

首先，输入命令`ping google.com`尝试能否 ping 谷歌官网，检查本地网络是否正常，却发现无法得到 TCP 回应，确定是本地网络连接出现问题。接着，输入命令`ip a`检查本地网络连接，果然发现朱网络接口 ens33 处于 DOWN 状态，这意味着虚拟机没有可用的网络连接，导致 DNS 失败（如图十七所示）。依次输入命令`sudo ip link set ens33 up`、`sudo dhclient ens33`来启动网卡、检查能否获取到 IP 地址，再输入命令`ip a`检查，发现 ens 33 处于 UP 状态，此时网络正常（如图十八所示）。接下来再次进行修复依赖关系，发现成功修改（如图十九所示），接着下载 PostgreSQL 发现成功下载（如图一所示）。

## 4. 课后实验内容及思考
### 4.1 隔离级别的影响：不同的隔离级别如何影响事务的行为？例如，Serializable 和 Read Committed 在并发环境下会如何表现？
SQL 标准定义了四种隔离级别，由低到高分别为：
- Read Uncommitted 读但未提交
- Read Committed 读已提交
- Repeatable Read 可重复读
- Serializable 可串行化

Read Committed 是 PostgreSQL 的默认隔离级别，事务只能看到其他已经提交的修改，正如实验中看到的那样，在该事务的执行期间，是无法看到其他事务对数据的修改的。

Serializable 是最高级别的隔离，每个事务都会感觉自己在独立运行，保证了事务执行结果与某种串行顺序执行的结果相同，完全防止脏读、不可重复读和幻读，并发性能较低，可能导致更多的事务中止。

### 4.2 锁定机制：PostgreSQL 在处理并发事务时使用了怎样的锁定机制？
1. MVCC 多版本并发控制

PostgreSQL 并不依赖传统的读写锁来实现并发控制，而是使用 MVCC，每次更新或删除删除数据时，并不会覆盖原始数据，而是会创建一个新的版本，每个事务只能看到它开始时存在的数据，如此一来便实现了读写操作互不阻塞，提高了并发性能。

2. 行级锁

当执行 UPDATE、DELETE 等语句时，PostgreSQL 会为目标数据行加锁，防止其他事务修改或删除同一行。该类型的锁不会阻塞读写操作，只会防止其他事务同时修改同一行数据。

3. 表级锁

用于保护整个表的数据结构，防止 DDL 操作冲突。表级锁有 ACCESS SHARE、ROW EXCLUSIVE、ACCESS EXCLUSIVE 等多种类型，多个表锁可以共存，PostgreSQL 使用一个锁兼容矩阵来管理它们之间的冲突。

4. 死锁检测与处理

当两个事务相互等待对方释放锁时，PostgreSQL 会触发死锁检测机制，一旦检测到死锁，会主动中止其中一个事务，释放资源。

5. 建议锁

这是一种由用户控制的锁，不依赖数据库内部的数据结构，可用于用户自定义的并发控制。

## 5. 实验总结
通过本次关于 PostgreSQL 数据库与事务管理的实验，我对数据库事务的基本概念、特性以及并发控制机制有了更深入的理解。在实验中，我首先完成了 PostgreSQL 数据库的安装与环境配置，学习了如何进入数据库终端、创建表格并插入数据，为后续的事务操作打下了基础。实际操作中，通过模拟两个终端同时对数据库进行读写操作，观察不同事务在不同隔离级别下的表现，清晰认识到事务提交前后的数据可见性变化，这帮助我直观地理解了事务的隔离性，尤其是 PostgreSQL 默认的 Read Committed 隔离级别对查询结果的影响。

实验的另一个重点是事务的锁定机制与并发控制。在两个事务同时修改同一数据项的情景下，系统自动为数据加锁，并使后一个事务进入等待状态，体现了数据库通过行级锁来维护数据一致性的设计理念。当第一个事务执行 abort 撤销操作后，后一个事务得以继续执行并成功提交，从而保证了事务的原子性。这些操作不仅让我熟悉了 PostgreSQL 的锁机制，也帮助我理解了 MVCC 背后的原理和优势，即读写操作互不阻塞的并发能力。

此外，我在实验过程中还遇到了一些技术问题，例如系统环境的依赖冲突和网络连接异常等，但通过逐步分析问题、使用 Linux 命令行进行故障排查和修复，最终成功完成了数据库的部署与测试。这一过程提升了我解决实际问题的能力，也加深了我对数据库系统工程的整体认知。实验最后的课后思考内容则促使我进一步反思事务在实际开发中的重要性，理解不同隔离级别在性能与一致性之间的权衡，以及 PostgreSQL 提供的多样化锁机制在复杂并发环境下的应用价值。

综上所述，本次实验不仅增强了我对数据库事务管理理论的理解，更通过动手实践深化了我对事务操作、并发控制和异常处理等关键技术的掌握。对事务执行过程的每一步进行了系统的观察和分析，使我能够将抽象的数据库原理与实际操作紧密结合，为今后从事数据库开发与管理打下了坚实的基础。