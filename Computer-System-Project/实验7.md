# 计算机系统安全
|姓名|学号|成绩评定|
|----|----|----|
|翟一航|23020011046||

## 1. 实验目的
1. 掌握数据安全和防御的基本操作；
2. 掌握缓冲区溢出攻击和防护的基本技术；
3. 理解如何利用安全技术，设计实现更安全的系统。

## 2. 实验过程与习题
### 2.1 分组密码算法
**操作：**
1. 产生32字节的密钥`key：os.urandom(32)`
2. 产生16字节的初始向量`iv`
3. 使用`cryptography.hazmat.primitives.ciphers`模块中的：
   - `Cipher, algorithms, modes`
4. 产生密码机c：`Cipher( algorithms.AES(key), modes.CBC(iv))`
5. 加密器e和解码器d：`cipher.encryptor() cipher.decryptor()`

写出代码如下：
```python
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

def main():
    # 生成 32 字节 (256 位) 的密钥
    key = os.urandom(32)

    # 生成 16 字节 (128 位) 的初始化向量 (IV)
    iv = os.urandom(16)

    # 创建 AES-CBC 密码机
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))

    # 创建加密器和解密器
    encryptor = cipher.encryptor()
    decryptor = cipher.decryptor()

if __name__ == "__main__":
    main()
```

**问题：**
- iv有什么用处？

   确保相同的明文和密钥最终加密出的结果也不同。即使使用相同的明文和密钥，但是由于使用的 iv 不同，最终生成的密文不同，可以防止攻击者通过重复的密文来推断明文和密钥，增强了安全性。

- 使用了什么加密算法？

   AES 加密算法，即对称加密算法，加密和解密使用相同的密钥。

- 使用了什么工作模式？这种工作模式有什么优缺点？

   使用 CBC 工作模式。
   
   优点：安全性较高，能够隐藏明文模式，即便相同的明文加密后密文也不同。

   缺点：由于每个密文块都依赖于前一块的密文，所以只能进行串行加密，无法并行。另外也无法抑制错误传播，若某个密文块损坏，会影响后续块的解密。

**操作：**
- 使用加密器e对消息：b`"hello ouc cser!"`进行加密
  - `ctxt = e.update (b"hello ouc cser!")+e.finalize()`

**问题：**
- 出现了什么错误？为什么？

   出现报错如图一所示，提示明文长度不是块长度的整数倍。这是因为 AES 加密算法在 CBC 工作模式之下，要求明文的长度必须是块长度（16字节）的整数倍，但是题目中所给的明文长度为15，不满足要求，所以会报错。

**操作：**
- 用填充的方法弥补以上错误，重新生成e并获得新消息的ctxt，打印出来
- 修改消息中1个字符，再次加密并打印密文，对比两次的密文

**问题：**
- 从两次的密文对比来看，有多少个Base64字符出现了变化？这说明加密算法应该有什么样的性质？

  用填充的方法弥补错误后的代码和先后两次输出密文的结果如图二所示。之后编写程序，以先后两次的密文为输入，计算它们Base64字符数的差异，发现有22个字符不同（如图三所示）。这体现出加密算法的性质如下：
  
  1. 明文即使是极其微小的变化，也会引起密文巨大的变动
  2. 密文与明文之间的联系是极其模糊的，无法通过密文来对明文进行推断，这也是好的密码算法的要求。

**操作：**

- 使用解密器d对密文进行解密
  - msg = d.update (ctxt)+d.finalize()
- 修改ctxt中的1个base64字符，重新解密

**问题：**

- 对比两次解密的结果，思考其体现出的算法性质

   操作结果如图四所示，可以发现两次结果差异巨大，修改一个base64字符后的新密文无法被解密为有效的信息，而是被解密成一串乱码。这说明加密算法具有错误传播的性质，即使只修改密文的一个字符，也会导致下一个明文块的完全随机错误，体现了分组密码算法的块依赖性与扩散性。

### 2.2 序列加密算法

**操作：**

1. 随机生成32字节key，16字节nonce
2. 用ChaCha序列密码算法生成密码机c，以及加密器e、解密器d
3. 对b"hello ouc cser!"进行加解密（不要填充）

**问题：**

- ChaCha是个什么样的算法，其安全性如何？

   操作结果如图五所示。ChaCha是一种流密码，用随机生成的32位key和16字节的nonce与计数器进行混合，生成密钥流，与明文进行逐字节的异或来进行加密。是一种高效安全的流密码，特别适合软件实现，比AES更抗侧信道攻击，在无硬件加速时更快，目前无已知的有效攻击。
   
- 为什么本次操作不需要急性填充？

   因为这是序列加密算法，直接生成与明文等长的密钥流，不需要再刻意保证明文与密钥的块对齐。

### 2.3 公钥密码算法

**操作：**

- rsa模块
- 生成私钥priv
- 生成公钥pub

**问题：**

- 2048的含义是什么？如果换成其他数字会怎样？

   2048表示RSA密钥的位数，即模数的二进制长度。2048可以抵御常规计算攻击，换成其他数字，如1024容易被破解，3072或2096则是更高的安全级别。随着密钥位数的增加，解密速度下降，内存占用增加。   

- 为什么第二季的模块名叫做hazmat？

   是“Hazardous Materials”的缩写，表示该模块提供的加密操作是低层、易误用、高风险的。

**操作：**

- 导入单向散列（hash）和填充模块
- 产生填充
- 加密b"OUC CSE GRADE 99"，再次加密b"OUC CSE GRADE 99"

**问题：**

- 两次加密的结果是否相同？为什么？

   结果如图六所示。不相同，这是因为OAEP天秤在加密时引入了随机数，所以即使加密的明文相同，两次加密的结果也不同，可以有效防止攻击者通过重复密文来推测明文。

- 如果加密算法未考虑填充，会有什么问题？

   安全性问题，相同明文会加密为相同的密文，容易被攻击，另外如果明文较短，可能会暴露密钥结构。除此还有功能性问题，RSA 只能加密比模数短短数据，填充确保明文长度适配密钥尺寸。

**操作：**

- 选择sha-256算法
- 生成hash器h
- 对消息求散列值d

**问题：**

- 密码学中的hash函数应具有什么性质？
  1. 确定性 同一输入 -> 永远输出相同的哈希值。
  2. 快速计算 哈希值的计算应高效
  3. 抗碰撞性 难以找到两个不同的输入，使得哈希值相同
  4. 抗原像性 给定哈希值d，难以找到m，使得hash(m) = d
  5. 不可逆性 无法从哈希值反推原数据

**操作：**

- 导入util模块
- 生成填充pad
- 对消息签名得到sig
- 验证签名

**问题：**

- 验证签名的函数，是如何返回验证成功或失败的消息给调用者的？为什么？
  结果如图七所示。如果验证成功，则静默通过无返回值。反之，则抛出异常。
  这样设计显式失败处理，防止忽略错误，并强制异常捕获。另外，符合密码学最佳实践，签名验证必须明确成功或失败，不能模糊。

### 2.4 缓冲区溢出防护技术

#### 2.4.1 canary防护

**操作：**

- gcc -fno-stack-protector -o test test.c
  - 禁用栈保护

- gcc -fstack-protector -o test test.c
  - 启用栈保护，只为局部变量中含 char 数组的函数插入保护代码

- gcc -fstack-protector-all -o test test.c
  - 启用栈保护，为所有函数插入保护代码

**问题：**

- Canary一词的来源是什么？借此解释Canary保护的原理
  操作结果见图八-图十三。Canary一词来源于 19世纪英国煤矿的早期安全实践。矿工下井时会携带金丝雀，因为这种鸟对 有毒气体（如甲烷、一氧化碳）极度敏感。如果金丝雀突然死亡，矿工便知道矿井中存在危险气体，需立即撤离。
  在计算机安全中，这是一种动态监测缓冲区溢出攻击的技术，其核心思想为：
  1. 植入”金丝雀“值，在程序的栈或堆堆关键位置插入一个随机值，该值在程序启动时随机生成，攻击者无法预测。
  2. 运行时检测 函数返回前系统会检查Canary值是否被篡改，篡改则判定为攻击，立即终止程序。
  3. 主动防御 Canary失效意味着攻击者已经尝试覆盖关键内存，此时程序崩溃比恶意代码更安全。

#### 2.4.2 Fortify保护

**操作：**

- gcc -o test test.c
  - 默认情况下，不会开这个检查

- gcc -D_FORTIFY_SOURCE=1 -o test test.c
  - 仅在编译时进行检查

- gcc -D_FORTIFY_SOURCE=2 -o test test.c
  - 程序执行时也会有检查

- gcc -D_FORTIFY_SOURCE=3 -o test test.c
  - 进一步增强安全性

**问题：**

- 当检测到溢出时，程序的行为有何变化？
  结果如图十四所示。当检测到溢出时，会立即终止程序，拒绝执行任何可能被攻击者控制的代码，并记录关键信息，生成安全的错误日志，生成核心转储，可用于事后分析漏洞。

#### 2.4.3 NX（DEP）

**操作：**

- gcc -o test test.c
  - 默认情况下，开启NX保护

- gcc -z execstack -o test test.c
  - 禁用NX保护

- gcc -z noexecstack -o test test.c
  - 开启NX保护

**问题：**

- 如何查看内存页的各项权限
  如图十五、图十六所示。可使用readelf或pmap、gdb工具查看
  
- 攻击者如何绕过NX防御？给出简单的步骤说明
  攻击者可以使用ROP方法，复用程序中已有的代码片段，通过链式调用实现恶意操作，具体步骤如下：

  1. 寻找gadgets，使用工具扫描目标程序或库，收集可用的指令片段。
  2. 构建ROP链，将gadgets地址按照需求排列，模拟系统调用
  3. 覆盖返回地址，通过缓冲区溢出，将返回地址指向ROP链的起始位置。

  此外，还有Ret2libc、JIT Spraying、mprotect 修改内存权限等方法。

#### 2.4.4 PIE（ASLR）

**问题：**

- PIE和PIC的区别？
  运行结果见图十七、图十八。
  
  PIE作用于主程序，使程序本身的加载地址随机化。
  PIC作用于共享库，确保库代码可在不同进程中共享，与ALSR无关。
- 如何查看程序的虚拟地址，如何体现地址随机化？
  可以使用/proc/\< PID \>/maps，或者pmap来查看，可以发现每次都地址都是不同的。

#### 2.4.5 RELRO保护

**问题：**

- 什么是GOT表？如何查看GOT表权限？
  运行结果如图十九所示。GOT（全局偏移表）是动态链接程序中的关键数据结构，用于在运行时解析和存储外部函数/变量的真实内存地址。主要作用：
  
  1. 延迟绑定：程序首次调用外部函数时，动态链接器通过GOT和PLT协作解析地址。
  2. 地址缓存：解析后的地址会存入GOT，后续调用直接跳转，避免重复解析
  
  
  可以使用readelf和gdb来查看GOT表权限。

### 2.5 进程安全防护技术

**问题：**

- 描述该技术的基本原理和简要流程，你认为可以如何改进它？
  LoadLord 技术的核心思想为动态加载干扰，通过运行时随机化动态库的加载顺序和基地址，破坏攻击者依赖的代码复用的稳定性，从而防御代码重用攻击。工作分为三个阶段，第一个阶段拦截动态链接器的函数调用，记录进程的库依赖关系，第二个阶段在库加载时，随机调整其内存映射顺序，第三个阶段攻击者的ROP链会因以来固定的gadgets地址失效。

  可以针对高危库启动深度随机优化，对频繁调用的库组合生成随机化方案，降低性能开销。

## 实验中遇到的问题与解决方案

**解密时出现报错`Context was already finalized`**

如图二十所示，这是因为解码器在之前已经被用于解码，程序中出现了对finalize的重复调用，而finalize调用后已经清空了上下文。需要进行重新声明，创建新的上下文。

## 实验总结

通过此次实验，我对密码学的分组加密算法、序列加密算法、公钥密码算法有了更深的理解，也了解了他们在实际生活中的应用，能够初步掌握这几种密码学算法在加密、解密中的应用。除此之外，还学习了缓冲区溢出防护技术，了解了gcc中的安全防护机制，特别是canary保护、Fortify保护、NX、PIE、RELRO保护等，知道了计算机在防护缓冲区溢出的机制。也了解了进程安全防护技术，学习了LoadLord技术，拓展了知识面，收益颇丰。
