# 可移植操作系统接口 POSIX

| 姓名   | 学号        | 成绩评定 |
| ------ | ----------- | -------- |
| 翟一航 | 23020011046 |          |

## 1. 实验目的

1. 基本了解POSIX I/O的编程规范;
2. 能够使用POSIX编程接口实现ls、cp等简单系统命令;
3. 巩固课堂学习的UNIX文件系统的基本设计。

## 2. 实验过程与习题

### 2.1 实现linux指令

**写出程序如下：**

> ls

```c
#include <stdio.h>
#include <dirent.h>

int main(int argc, char *argv[]) {
    const char *path = (argc > 1) ? argv[1] : ".";
    DIR *dir = opendir(path);
    if (!dir) {
        perror("opendir failed");
        return 1;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
    }
    closedir(dir);
    return 0;
}
```

运行结果见图一，对程序进行编译后开始测试。首先输入命令`./myls`，列出当前目录下的文件信息，再输入命令`./myls /etc`，列出指定目录 /etc 下的文件信息。

> cp

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

#define BUF_SIZE 4096

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: %s <source> <destination>\n", argv[0]);
        return 1;
    }

    int src = open(argv[1], O_RDONLY);
    if (src < 0) {
        perror("source open failed");
        return 1;
    }

    int dst = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (dst < 0) {
        perror("destination open failed");
        close(src);
        return 1;
    }

    char buf[BUF_SIZE];
    ssize_t bytes;
    while ((bytes = read(src, buf, BUF_SIZE)) > 0) {
        write(dst, buf, bytes);
    }

    close(src);
    close(dst);
    return 0;
}
```

运行结果见图二，同样对程序进行编译后测试。复制文件`myls.c`产生副本文件`backup.c`，之后输出这两个文件的信息，再使用`diff`命令进行不同处检查，没有输出，说明两文件一致。

> chmod

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: %s <mode> <file>\n", argv[0]);
        return 1;
    }

    mode_t mode = strtol(argv[1], NULL, 8);
    if (chmod(argv[2], mode) != 0) {
        perror("chmod failed");
        return 1;
    }

    printf("Permission changed: %s -> %s\n", argv[2], argv[1]);
    return 0;
}
```

运行结果见图三，编译后进行测试。首先创建空白文件`text.txt`，并输出文件权限。之后输入命令`./mychmod 600 test.txt`修改文件权限为只有所有者可以进行读写，600为八进制的权限表示。再输出文件权限进行检查。

**要求与思考：**

- 如何让程序实现更接近系统指令，例如：对命令行参数的支持

**答：**

- 使用 argc 和 argv 来支持命令行参数，使用`main(int argc, char *argv[])`，可以接收文件名、权限等参数
- 还可以使用`getopt()`来支持选项参数。

### 2.2 文件空洞实验

**写出程序代码如下：**

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

int main() {
    const char *filename = "hole.file";

    // O_CREAT: create if not exists
    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        perror("failed to open file");
        return 1;
    }

    // 写入前缀数据
    const char *start = "BEGIN";
    if (write(fd, start, strlen(start)) != (ssize_t)strlen(start)) {
        perror("write BEGIN");
        close(fd);
        return 1;
    }

    // lseek 跳过一个大段空洞
    off_t offset = 5 * 1024 * 1024;  // 5MB
    if (lseek(fd, offset, SEEK_CUR) < 0) {
        perror("lseek failed");
        close(fd);
        return 1;
    }

    // 写入末尾数据
    const char *end = "END";
    if (write(fd, end, strlen(end)) != (ssize_t)strlen(end)) {
        perror("write END");
        close(fd);
        return 1;
    }

    close(fd);
    return 0;
}
```

**问题：**

- 解释出现的现象

**答：**

- 首先对程序进行编译运行，之后输入命令`ls -lh hole.file`，`du -h hole.file`来分别查看文件的逻辑大小和实际占用空间。发现逻辑上占用了5.1MB，但是实际上却仅仅占用了8KB。使用od命令查看文件内容，发现中间大量的空洞区域由`\0`填充。接下来输入命令`cat hole.file > hole.cat`将文件重定向，再使用cp复制原文件，最终再进行比较，发现只有.cat文件时间占用空间与逻辑上相同。（见图四、图五，图六）

- 在将文件重定向的过程中，会逐字节输出，无法保留空洞，因而实际占用空间会变大。但是，cp却会保留空洞。

### 2.3 探究文件类型

**写出代码如下：**

```c
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void print_file_type(const char *filepath) {
    struct stat fileinfo;

    if (stat(filepath, &fileinfo) != 0) {
        perror(filepath);
        return;
    }

    printf("%s: ", filepath);

    if (S_ISREG(fileinfo.st_mode))
        puts("regular file");
    else if (S_ISDIR(fileinfo.st_mode))
        puts("directory");
    else if (S_ISLNK(fileinfo.st_mode))
        puts("symbolic link");
    else if (S_ISCHR(fileinfo.st_mode))
        puts("character special file");
    else if (S_ISBLK(fileinfo.st_mode))
        puts("block special file");
    else if (S_ISFIFO(fileinfo.st_mode))
        puts("FIFO (named pipe)");
    else if (S_ISSOCK(fileinfo.st_mode))
        puts("socket");
    else
        puts("unknown type");
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <file1> [file2] [...]\n", argv[0]);
        return 1;
    }

    for (int i = 1; i < argc; ++i) {
        print_file_type(argv[i]);
    }

    return 0;
}
```

使用命令`./filetype /etc/passwd /dev/null /dev/sda /tmp /run/systemd/private`查看这些目录下的文件类型，再用ls命令验证。（见图七）

### 2.4 文件链接实验

**写出代码如下：**

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

int main() {
    const char *filename = "tempfile.log";
    
    // 打开文件，如果不存在就创建，清空内容
    int fd = open(filename, O_RDWR | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        perror("open failed");
        return 1;
    }

    // 写入一些内容（比如10MB）
    const int block_size = 1024 * 1024; // 1MB
    char *buffer = malloc(block_size);
    memset(buffer, 'A', block_size);  // 填充内容

    for (int i = 0; i < 10; ++i) {
        if (write(fd, buffer, block_size) != block_size) {
            perror("write failed");
            close(fd);
            free(buffer);
            return 1;
        }
    }

    free(buffer);
    fsync(fd); // 确保写入磁盘

    // 立即解除链接
    if (unlink(filename) < 0) {
        perror("unlink failed");
        close(fd);
        return 1;
    }

    printf("File '%s' unlinked. Sleeping for 15 seconds...\n", filename);
    sleep(15);

    // 结束进程（文件描述符随进程释放，空间将回收）
    close(fd);
    printf("Program finished.\n");
    return 0;
}
```

在程序运行前/中/后分别查看文件是否存在以及当前文件系统使用情况，如图八-图十所示。

## 实验过程与遇到的问题与解决方法

**问题：**

- 在实现`cp`命令时，目标文件的权限设置不正确，导致复制后的文件权限与源文件不一致。

**解决方法：**

- 使用`fstat`获取源文件权限，然后在创建目标文件时使用相同的权限模式。

**问题：**

- 最初不理解文件空洞的实现原理，直接写入大量零值导致实际占用空间过大。

**解决方法：**

- 使用`lseek`跳过空洞区域，只在文件开头和结尾写入少量数据，中间保持空洞。

## 实验总结

通过本次实验，我深入理解了POSIX I/O编程接口的使用方法，包括文件操作、目录遍历、权限控制等核心功能。通过实现ls、cp、chmod等基本功能，我理解了这些常用工具的原理，学会了如何处理命令行参数。通过空洞实验，我理解了稀疏文件的实现原理，以及可以使用稀疏文件来节省空间。通过文件链接实验，学会了解除文件链接的方法，了解了空间回收机制。除此之外，通过此次试验还还培养了我对文件系统底层机制的认知，为我之后操作系统相关学习和开发打下了坚实基础。
