# MapReduce
## 工程师提出 MapReduce 的编程模型和实现，他们的性能目标是什么？
以谷歌为例，在过去的时间中员工执行了大量的计算任务，这些任务要处理大量的原始数据，大多数的此类计算在概念上都很简单，但是由于输入数据规模庞大，并且这些计算必须分布在数百或数千台机器上来提高计算速度，并行化计算、数据分配、故障处理等因素共同作用导致简单的计算被大量复杂的代码覆盖。MapReduce 正是为了解决这种复杂性而被设计出来的，它提供了简单且强大的接口，来实现大规模计算的自动化并行与分布式处理，并且该接口的实现能够在由普通个人电脑组成的大型集群上也实现高性能的运行。

## Google 是怎么通过实现去满足这些目标的？
通过 MapReduce 函数。
首先，用户程序的 MapReduce 库将输入的文件分为 M 个部分，然后在一组机器上启动该程序的多个副本，其中包含一个 master，其余都是 worker，worker 由 master 分配任务。任务被分为 M 个 map 任务和 R 个 reduce 任务，内存也随之被分割为多个分区，master 找到空闲的工作副本，为每一个空闲的 worker 分配一个任务。
负责 map 任务的 worker从输入数据中解析出键值对，并将之传给用户定义的映射函数，映射函数产生的中间键值对被储存在内存中。
每隔一段时间，缓冲区中的数据被写入本地磁盘，并且通过分区函数被划分为 R 个区域，这些位置被返回给 master，master 又将这些位置转发给 负责 reduce 任务的 worker。worker 收到通知后远程调用从本地磁盘中读取缓冲数据，读取完所有中间数据后按照中间键对其进行排序，便于将相同键的所有出现情况归为一组。
reduce worker 遍历中间数据，遇到唯一的中间键就将其对应的中间值集合传递给 reduce 函数，函数的输出被附加到此 reduce 分区的最终输出文件中。
所有的 map 任务和 reduce 任务完成后，master 会唤醒用户程序，用户程序中的 MapReduce 调用返回到用户代码中，输出结果以 R 个输出文件的形式呈现，可以将这些文件作为输入传递给另一个 MapReduce 调用，或者使用它们从能够处理多文件分区输入的其他分布式应用程序中获取。
除此之外还有周期性故障检测机制。master 定期 ping 每个 worker，如果一定时间内没有收到回复，会将该 worker 标记为 failed。该 worker 完成的任何 map 任务都会重置，并且分配给其他 worker。如果 master 终止，可以从最后的检查点状态重新启动新的副本（由于只有一个 master，其出现故障的可能性不大）。

## MapReduce 为什么选择这样实现，而没有走其他技术道路？
1. MapReduce 实际上可以被视为对大规模实际计算经验的总结，以及一些其他模型的简化，并且提供了透明容错机制，能够扩展到多个处理器，优于多数其他并行系统仅能在较小的规模上实现，并将处理程序故障的细节留给程序员，系统的可靠性与性能得到提升。
2. 这样的设计使得该模型易于使用，隐藏并行化、容错性、局部性优化和负载均衡的细节，很多问题都可以很轻松地使用 MapReduce 计算来表达，也有效地实现了资源的利用。
3. 如此实现也使得程序易于改进，满足了计算机系统工程的迭代设计原则——既然不能一次成功，就使它易于修改。对每个部分、每个阶段都进行了模块化，不仅对系统的局部功能进行了优化，也方便之后对系统进行针对性的优化。
