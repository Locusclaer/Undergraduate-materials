# Byzantine
## 1. 拜占庭将军问题是什么 (它阐述了什么)?
拜占庭军队想要攻打一个城池，军队分为多个队伍，每支队伍都有自己的将领，他们将想要攻打的城池团团围住，这些将领之间只能通过信使来进行交流，他们必须就共同的作战计划达成一致，来决定进攻还是撤退、何时进攻等。他们中间存在一名或者多名叛徒，他们会试图传递错误信息或者不传递信息来迷惑他人。在这种情况下，要找到一种算法，确保忠诚的将领们能够达成一致。在计算机分布式系统中，将领代表分布式系统中的节点或者进程，其中忠诚的将领是正常工作的节点，指挥官是发起提案的节点，副官是其他参与协作的节点，叛徒则是系统中的故障节点或者恶意节点。消息则代表节点之间的通信包，其中口头消息可能被篡改或者伪造，是不可靠通信，签名消息可验证来源无法被伪造，是安全通信。

## 2. 如何确保忠诚的将军能够达成一致的行动计划？
有两种经典的分布式容错算法，分别是 OM(m) 算法和 SM(m) 算法。

### OM(m) 算法：
这种方法的前提是，如果有 m 个叛徒，那么至少需要有 3m + 1 个将领，否则问题无解，并且任意两个将领之间都能够进行直接通信，通信网络是完全连通的。其中发送消息的将领被称为指挥官，其余的将领被称为副官，如果没有收到消息则默认撤退。消息通过口头协议传递，即消息可能被伪造或篡改。假设任何消息都可以正确无误地送达，并且消息的接受者可以知道是谁发送的消息，没有收到消息会被检测出来。

这个算法总共分为两步递归进行。

- 第一步：OM(0) ：
指挥官向所有的副官发送自己的命令，如果没有叛徒的话，每个副官都会直接采用指挥官的命令。
- 第二步：OM(m)：
对于每个副官，如果他是忠诚的，他收到命令后就会通过 OM(m - 1) 发给其他的副官，不包括自己和指挥官。最终每个副官收集所有收到的命令，包括直接来自指挥官的和间接来自别的副官的，采用多数投票的结果作为最终的命令。

如此一来由于 n >= 3m + 1，所以即便存在 m 个叛徒，由于多数投票和递归机制，忠诚的将领们可以交叉验证指挥官和其他副官的消息，最终也能够达成一致的结果。

### SM(m) 算法：
这种方法的前提是，消息的传递使用签名消息，即不可以被伪造和篡改，并且能够验证消息的来源。每条消息都由发送者签名，并且签名不可以被篡改，接受者可以验证消息的真实性，叛徒也无法伪造忠诚将领的签名，只能拒绝转发或者发送自己的错误消息。叛徒的数量只需要满足 n >= m + 2，条件更加宽松。

这个算法分为三步，无需进行递归，复杂度更低，并且对叛徒数量的容忍度更高。

- 第一步：
指挥官发送命令给所有副官。
- 第二步：
每个副官收到命令之后，如果是第一次收到该命令则签名并转发给其他的副官，如果之前已经收到过该命令则不会再转发。
- 第三步：
每个副官收集所有的签名消息，对签名消息进行检查一旦发现有命令篡改便会进行处理，协商出最终的命令。

如此一来，无论是忠诚的将领还是叛徒先发起协商，最终都能够检查出叛徒并且对篡改后的消息进行处理，最终得到正确的命令。

## 3. 拜占庭将军问题的解决方案能够应用于哪些计算领域？
论文中的拜占庭将军问题是对于计算机分布式系统对处理向系统中不同部分提供矛盾信息的故障组件的抽象，说明该问题的解决方法能够应用于计算机的分布式系统的可靠性维护中。但是在实际生活中，拜占庭将军问题的解决方案还被应用于以下几个领域：

1. 区块链与加密货币
搭建有限信任环境，对恶意节点进行处理。
2. 云计算与分布式数据库
进行跨地域部署的数据库副本的数据同步，确保微服务架构中服务调用的可靠性。
3. 物联网与边缘计算
大规模设备的协同决策、边缘节点的真实性验证。

此外还被应用于航空航天、金融与支付系统、军事与安全通信、人工智能等领域